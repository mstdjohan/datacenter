<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CAKE/USDT — UT Bot (KV=1, ATR=10) + MinGap % + EmailJS</title>

<!-- Lightweight Charts -->
<script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
<!-- EmailJS (browser) -->
<script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>

<style>
  :root{--bg:#07121a;--panel:#0b1820;--muted:#9fb4c9;--text:#e6f6ff;--ok:#22c55e;--bad:#ef4444}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);padding:12px}
  .wrap{max-width:1100px;margin:0 auto}
  .card{background:var(--panel);border-radius:12px;padding:12px;border:1px solid #0f2430}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:16px;margin:0}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
  input,select,button{padding:8px;border-radius:8px;border:1px solid #123140;background:#08121a;color:var(--text)}
  button{cursor:pointer}
  button.primary{background:var(--ok);color:#04160a;border:0;font-weight:700}
  .pill{padding:6px 10px;border-radius:999px;background:#081923;border:1px solid #153241;color:var(--muted);font-size:12px}
  #chart{height:520px;border-radius:8px;overflow:hidden}
  .log{height:180px;overflow:auto;background:#051016;border:1px solid #0f2833;border-radius:8px;padding:8px;font-family:ui-monospace,monospace;font-size:13px;margin-top:12px}
  label.small{font-size:13px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .note{font-size:13px;color:var(--muted);margin-top:6px}
  @media(max-width:900px){#chart{height:360px}.grid{grid-template-columns:1fr 1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>CAKE/USDT — UT Bot (KV=1, ATR=10) + MinGap %</h1>
      <div class="note">Sinyal BUY/SELL muncul di chart. Isi EmailJS di bawah lalu klik Save untuk mengaktifkan email.</div>
    </div>
    <div class="controls">
      <div class="pill">Pair: CAKE/USDT</div>
      <div class="pill">TF: 5m</div>
      <button id="btnLoad" class="primary">Load Now</button>
    </div>
  </header>

  <div class="card">
    <div id="chart"></div>

    <div class="grid">
      <div>
        <label class="small">Polling interval (sec)</label>
        <input id="pollSec" type="number" value="30" min="5">
      </div>
      <div>
        <label class="small">Candles to fetch (limit)</label>
        <input id="limit" type="number" value="500" min="100" max="1000">
      </div>
      <div>
        <label class="small">Minimal Gap % (minGap)</label>
        <input id="minGap" type="number" value="1" step="0.1" min="0"> 
        <div class="note">Jika entryPrice ada, sinyal diabaikan bila selisih &lt; minGap%</div>
      </div>
    </div>

    <div style="height:8px"></div>
    <div class="card" style="margin-top:8px">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <label class="small">EmailJS Service ID</label>
        <input id="emailService" placeholder="service_xxx" style="width:180px">
        <label class="small">Template ID</label>
        <input id="emailTemplate" placeholder="template_xxx" style="width:180px">
        <label class="small">Public Key</label>
        <input id="emailUser" placeholder="user_xxx" style="width:180px">
        <button id="btnSaveEmail">Save</button>
        <button id="btnTestEmail" disabled>Test Email</button>
      </div>
      <div class="note">Template harus menerima fields: action, pair, price, time, interval.</div>
    </div>

    <div class="log" id="log"></div>
  </div>
</div>

<script>
/* Full single-file UT Bot with minGap %
   - Default: CAKEUSDT 5m, UT Bot KV=1 ATR=10
   - EmailJS requires user to fill service/template/user via UI then Save
   - Dedupe: one email per bar (lastSentBar)
*/

const logEl = document.getElementById('log');
function log(...a){ const t=(new Date()).toLocaleTimeString(); const s=a.map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' '); logEl.textContent = `[${t}] ${s}\n` + logEl.textContent; console.log(...a); }
const $ = id => document.getElementById(id);

// load/save EmailJS config
function loadEmailCfg(){
  try{
    const raw = localStorage.getItem('ut_email_cfg');
    if(!raw) return;
    const cfg = JSON.parse(raw);
    $('emailService').value = cfg.service||'';
    $('emailTemplate').value = cfg.template||'';
    $('emailUser').value = cfg.user||'';
    if(cfg.user && window.emailjs && emailjs.init) emailjs.init(cfg.user);
    updateEmailReady();
    log('EmailJS config loaded');
  }catch(e){ log('loadEmailCfg err', e.message); }
}
function saveEmailCfg(){
  const cfg = { service: $('emailService').value.trim(), template: $('emailTemplate').value.trim(), user: $('emailUser').value.trim() };
  localStorage.setItem('ut_email_cfg', JSON.stringify(cfg));
  if(cfg.user && window.emailjs && emailjs.init) try{ emailjs.init(cfg.user); }catch(e){}
  updateEmailReady();
  log('EmailJS config saved');
}
function updateEmailReady(){
  const ok = $('emailService').value && $('emailTemplate').value && $('emailUser').value;
  $('btnTestEmail').disabled = !ok;
}

// chart
let chart = null, candleSeries = null;
function createChart(){
  if(chart && candleSeries) return;
  const el = document.getElementById('chart');
  el.innerHTML = '';
  chart = LightweightCharts.createChart(el, {
    layout:{ background:{color:'#07121a'}, textColor:'#dff0ff' },
    rightPriceScale:{ borderColor:'#0f2430' },
    timeScale:{ borderColor:'#0f2430' }
  });
  candleSeries = chart.addCandlestickSeries({ upColor:'#16a34a', downColor:'#ef4444', wickUpColor:'#16a34a', wickDownColor:'#ef4444' });
  window.addEventListener('resize', ()=> chart.applyOptions({ width: el.clientWidth }));
  log('Chart initialized');
}
createChart();

// Binance fetch
const PAIR = 'CAKEUSDT';
const INTERVAL = '5m';
function binanceIntervalToQuery(i){ return i; }
async function fetchKlines(symbol, interval, limit=500){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${binanceIntervalToQuery(interval)}&limit=${limit}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Binance fetch error: '+r.status);
  const j = await r.json();
  return j.map(k => ({ time: Math.floor(k[0]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5] }));
}

// ATR / UT Bot (KV=1, ATR=10)
function trueRange(candles){
  const tr = new Array(candles.length).fill(NaN);
  for(let i=1;i<candles.length;i++){
    const a=candles[i], b=candles[i-1];
    tr[i] = Math.max(a.high - a.low, Math.abs(a.high - b.close), Math.abs(a.low - b.close));
  }
  return tr;
}
function computeATR(candles, period=10){
  const tr = trueRange(candles);
  const atr = new Array(candles.length).fill(NaN);
  if(tr.length<=period) return atr;
  let sum=0;
  for(let i=1;i<=period;i++) sum += tr[i] || 0;
  atr[period] = sum/period;
  for(let i=period+1;i<tr.length;i++){ atr[i] = ( (atr[i-1]*(period-1)) + tr[i] ) / period; }
  return atr;
}
function computeUT(candles){
  const atr = computeATR(candles, 10);
  const n = candles.length;
  const finalUpper = new Array(n).fill(NaN), finalLower = new Array(n).fill(NaN);
  const trend = new Array(n).fill(0), signals = [];
  for(let i=0;i<n;i++){
    if(!isFinite(atr[i])) continue;
    const hl2 = (candles[i].high + candles[i].low)/2;
    const up = hl2 + 1 * atr[i];   // KV = 1
    const low = hl2 - 1 * atr[i];
    if(i===0){ finalUpper[i]=up; finalLower[i]=low; trend[i]=1; continue; }
    finalUpper[i] = (up < finalUpper[i-1]) ? up : finalUpper[i-1];
    finalLower[i] = (low > finalLower[i-1]) ? low : finalLower[i-1];
    const prev = trend[i-1] || 1;
    if(candles[i].close > finalUpper[i-1]) trend[i] = 1;
    else if(candles[i].close < finalLower[i-1]) trend[i] = -1;
    else trend[i] = prev;
    if(trend[i] !== trend[i-1]){
      const type = trend[i] === 1 ? 'buy' : 'sell';
      signals.push({ index: i, type, time: candles[i].time, price: candles[i].close });
    }
  }
  return { atr, finalUpper, finalLower, trend, signals };
}

// render + signal handling
let lastSentBar = null;
let candlesCache = [];
let entryPrice = null; // stores last executed buy price (or null)
function render(candles){
  if(!candleSeries) createChart();
  candleSeries.setData(candles);
  const ut = computeUT(candles);
  const markers = ut.signals.map(s => ({
    time: candles[s.index].time,
    position: s.type==='buy' ? 'belowBar' : 'aboveBar',
    color: s.type==='buy' ? '#16a34a' : '#ef4444',
    shape: s.type==='buy' ? 'arrowUp' : 'arrowDown',
    text: s.type.toUpperCase()
  }));
  try{ candleSeries.setMarkers(markers); }catch(e){ console.warn('setMarkers err', e); }

  // evaluate newest signal & minGap filter
  if(ut.signals.length){
    const last = ut.signals[ut.signals.length-1];
    const nowBar = last.time;
    if(nowBar !== lastSentBar){
      // minGap percent:
      const minGapPct = Math.max(0, Number($('minGap').value) || 1) / 100;
      let allow = true;
      if(entryPrice !== null){
        const diff = Math.abs((last.price - entryPrice) / entryPrice);
        if(diff < minGapPct) { allow = false; log(`Signal ${last.type.toUpperCase()} ignored (gap ${ (diff*100).toFixed(3) }% < minGap ${ (minGapPct*100).toFixed(3) }%)`); }
      }
      if(allow){
        log('Signal detected:', last.type.toUpperCase(), 'price', last.price);
        sendSignalEmail(last.type.toUpperCase(), PAIR, last.price, INTERVAL).catch(e=>log('Email error', e));
        lastSentBar = nowBar;
      }
    }
  }
}

// Email send (needs config saved via UI)
function isEmailConfigured(){
  return $('emailService').value.trim() && $('emailTemplate').value.trim() && $('emailUser').value.trim();
}
async function sendSignalEmail(action, pair, price, interval){
  try{
    const svc = $('emailService').value.trim();
    const tmpl = $('emailTemplate').value.trim();
    const user = $('emailUser').value.trim();
    if(!svc || !tmpl || !user){
      log('EmailJS not configured - skip email');
      return;
    }
    emailjs.init(user);
    const payload = { action:`[UT-BOT] ${action}`, pair, price:String(price), time:new Date().toLocaleString(), interval };
    const res = await emailjs.send(svc, tmpl, payload);
    log('Email sent', { status: res.status, text: res.text || '' });
  }catch(e){ log('sendSignalEmail error: '+(e && (e.text||e.message) || e)); }
}

// polling
async function loadAndRender(){
  try{
    const limit = Math.max(100, Math.min(1000, Number($('limit').value) || 500));
    const data = await fetchKlines(PAIR, INTERVAL, limit);
    candlesCache = data;
    render(candlesCache);
    log('Rendered candles:', candlesCache.length);
  }catch(e){ log('loadAndRender error: '+(e.message||e)); }
}

let pollTimer = null;
function startAuto(){
  stopAuto();
  const sec = Math.max(5, Number($('pollSec').value) || 30);
  loadAndRender();
  pollTimer = setInterval(loadAndRender, sec*1000);
  log('Auto polling started every '+sec+'s');
}
function stopAuto(){ if(pollTimer){ clearInterval(pollTimer); pollTimer=null; log('Auto polling stopped'); } }

document.getElementById('btnLoad').onclick = loadAndRender;
document.getElementById('btnSaveEmail').onclick = saveEmailCfg;
document.getElementById('btnTestEmail').onclick = async ()=>{
  try{
    if(!window.emailjs || !emailjs.send){ alert('EmailJS SDK not loaded'); return; }
    const svc = $('emailService').value.trim(), tmpl = $('emailTemplate').value.trim(), user = $('emailUser').value.trim();
    if(!svc || !tmpl || !user){ alert('Fill service/template/user'); return; }
    emailjs.init(user);
    const payload = { action:'[TEST] UT-BOT', pair:PAIR, price:'0', time:new Date().toLocaleString(), interval:INTERVAL };
    await emailjs.send(svc, tmpl, payload);
    log('Test email sent');
  }catch(e){ log('Test email failed: '+(e && (e.text||e.message) || e)); alert('Test failed - check log'); }
};

loadEmailCfg();
startAuto();

// expose debug
window._ut = { loadAndRender, render, computeUT, sendSignalEmail };

</script>
</body>
</html>
