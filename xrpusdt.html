<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="refresh" content="420">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto-Trading XRP ‚Äî Final (Auto-connect & Auto-refresh)</title>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>

  <style>
    :root{--bg:#f6f7fb;--card:#fff;--muted:#6b7280;--danger:#ef4444;--success:#10b981}
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:#0f172a}
    .container{max-width:1100px;margin:20px auto;padding:18px}
    header{display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;font-size:18px}
    .muted{color:#6b7280;font-size:13px}
    .grid{display:grid;grid-template-columns:340px 1fr;gap:14px;margin-top:12px}
    .card{background:var(--card);padding:12px;border-radius:8px;box-shadow:0 1px 6px rgba(2,6,23,0.06)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
    button{padding:8px 10px;border-radius:6px;border:1px solid #e6eef0;background:#fff;cursor:pointer}
    .btn-primary{background:linear-gradient(90deg,#06b6d4,#06a6b9);color:#fff;border:none}
    .btn-danger{background:var(--danger);color:#fff;border:none}
    input,select{padding:8px;border-radius:6px;border:1px solid #e6eef0;width:100%}
    .stat{display:flex;justify-content:space-between;padding:8px;border-radius:6px;background:#fafafa;border:1px solid #eef2f7;margin-bottom:6px}
    #log{font-family:monospace;white-space:pre-wrap;height:220px;overflow:auto;padding:10px;background:#0b1220;color:#dbeafe;border-radius:6px}
    #chart{height:360px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    .small{font-size:13px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>üìä Auto-Trading XRP ‚Äî Final</h1>
        <div class="muted">Strategy: Bollinger Bands (intact). Auto-connect & auto-refresh every 7 minutes added.</div>
      </div>
      <div style="text-align:right">
        <div class="muted small">Status</div>
        <div id="statusBadge" style="padding:6px 10px;border-radius:8px;background:#fff;border:1px solid #e6eef0">Not connected</div>
      </div>
    </header>

    <div class="grid">
      <!-- Left: controls -->
      <div>
        <div class="card">
          <div class="controls">
            <button id="connectBtn" class="btn-primary">üîó Connect MetaMask</button>
            <button id="refreshBalancesBtn">üîÑ Refresh Balances</button>
          </div>

          <div style="margin-top:8px">
            <div class="stat"><div>üëõ Wallet</div><div id="walletAddress" class="small muted">Belum terhubung</div></div>
            <div class="stat"><div>üíµ Saldo BNB</div><div id="bnbBalance" class="small">-</div></div>
            <div class="stat"><div>üíº Modal (USD)</div><div id="capital" class="small">$1000.00</div></div>
            <div class="stat"><div>üí∞ Harga Live XRP</div><div id="livePrice" class="small">Memuat...</div></div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div class="small muted" style="margin-bottom:8px">Copy-Trade Mode</div>

          <label class="small">Mode</label>
          <select id="copyMode" style="margin-top:6px;margin-bottom:8px">
            <option value="signal">Follow Signal API</option>
            <option value="wallet">Follow Leader Wallet (on-chain)</option>
          </select>

          <div id="signalSettings" style="margin-top:8px">
            <label class="small">Signal API URL</label>
            <input id="signalUrl" placeholder="https://api.provider/signals" />
            <label class="small" style="margin-top:8px">Bearer Token (optional)</label>
            <input id="signalToken" placeholder="Authorization token" />
            <div style="margin-top:8px;display:flex;gap:8px">
              <button id="enableCopyBtn">‚ñ∂Ô∏è Enable Copy-Trade (OFF)</button>
              <button id="mockSignalBtn">üß™ Mock Signals (ON)</button>
            </div>
          </div>

          <div id="walletSettings" style="display:none;margin-top:8px">
            <label class="small">Leader Wallet Address</label>
            <input id="leaderAddress" placeholder="0xLeaderAddress..." />
            <label class="small" style="margin-top:8px">BscScan API Key</label>
            <input id="bscscanKey" placeholder="(required for txlist polling)" />
            <div style="margin-top:8px;display:flex;gap:8px">
              <button id="followWalletBtn">üîé Start Following Wallet</button>
              <button id="stopFollowBtn" style="display:none">‚õî Stop Following</button>
            </div>
            <div class="muted small" style="margin-top:8px">Follow-wallet decodes PancakeSwap swaps and mirrors them (scaled).</div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div class="small muted" style="margin-bottom:8px">Manual Controls & Safety</div>
          <div style="display:flex;gap:8px;margin-bottom:8px">
            <button id="manualBuy">üü¢ BUY (Manual)</button>
            <button id="manualSell" class="btn-danger">üî¥ SELL (Manual)</button>
            <button id="resetBtn">üîÅ Reset Simulasi</button>
          </div>

          <label class="small">Follow trade size scale (fraction of leader amount)</label>
          <input id="followScale" placeholder="e.g. 0.5 (50%)" value="0.5" />

          <label class="small" style="margin-top:8px">Max execution amount (human units)</label>
          <input id="maxExec" placeholder="e.g. 5 (USDT/XRP units)" value="5" />
        </div>
      </div>

      <!-- Right: chart + log -->
      <div>
        <div class="card" style="height:420px;display:flex;flex-direction:column">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div class="small muted">XRP / USDT ‚Äî Live (Line) ‚Äî Bollinger Bands</div>
            <div class="small muted">Interval: 30s</div>
          </div>
          <canvas id="chart"></canvas>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div class="small muted">Activity Log</div>
            <div class="small muted">Actions & copy events</div>
          </div>
          <div id="log"></div>
        </div>
      </div>
    </div>

    <footer>Disclaimer: Auto-execution is risky. Start with small amounts. Ensure MetaMask in BSC Mainnet & enough BNB for gas.</footer>
  </div>

<script>
/* -------------------- Configuration -------------------- */
emailjs.init("aPZx0R9oxUbIQkLEv"); // keep your EmailJS id
const COINGECKO_PRICE_API = "https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd";
const BSC_RPC_READ = "https://bsc-dataseed.binance.org/";
const PANCAKE_ROUTER = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
const routerABI = [
  "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external",
  "function getAmountsOut(uint amountIn,address[] calldata path) external view returns (uint[] memory)"
];

// Confirmed addresses you asked to hardcode:
const XRP_ADDRESS = "0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE";
const USDT_ADDRESS = "0x55d398326f99059fF775485246999027B3197955";

/* -------------------- State (unchanged strategy vars) -------------------- */
let priceData = [], timeLabels = [];
let currentCapital = parseFloat(localStorage.getItem('capital')) || 1000;
let qtyPerTrade = 1000;
let lastBuy = localStorage.getItem('lastBuy') ? parseFloat(localStorage.getItem('lastBuy')) : null;
let currentPositionAmount = localStorage.getItem('positionAmount') ? parseFloat(localStorage.getItem('positionAmount')) : 0;

/* DOM refs */
const statusBadge = document.getElementById('statusBadge');
const walletAddressEl = document.getElementById('walletAddress');
const bnbBalanceEl = document.getElementById('bnbBalance');
const capitalEl = document.getElementById('capital');
const livePriceEl = document.getElementById('livePrice');
const logEl = document.getElementById('log');

const connectBtn = document.getElementById('connectBtn');
const refreshBalancesBtn = document.getElementById('refreshBalancesBtn');
const enableCopyBtn = document.getElementById('enableCopyBtn');
const mockSignalBtn = document.getElementById('mockSignalBtn');
const copyModeSelect = document.getElementById('copyMode');

const signalUrlInput = document.getElementById('signalUrl');
const signalTokenInput = document.getElementById('signalToken');

const leaderAddressInput = document.getElementById('leaderAddress');
const bscscanKeyInput = document.getElementById('bscscanKey');
const followWalletBtn = document.getElementById('followWalletBtn');
const stopFollowBtn = document.getElementById('stopFollowBtn');

const manualBuyBtn = document.getElementById('manualBuy');
const manualSellBtn = document.getElementById('manualSell');
const resetBtn = document.getElementById('resetBtn');
const followScaleInput = document.getElementById('followScale');
const maxExecInput = document.getElementById('maxExec');

/* Chart.js */
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx, {
  type: 'line',
  data: {
    labels: timeLabels,
    datasets: [
      { label:'Harga', data: priceData, borderColor:'#0f172a', fill:false },
      { label:'EMA-12', data:[], borderColor:'#2563eb', fill:false },
      { label:'EMA-26', data:[], borderColor:'#7c3aed', fill:false },
      { label:'Upper BB', data:[], borderColor:'#16a34a', borderDash:[5,5], fill:false },
      { label:'Lower BB', data:[], borderColor:'#ef4444', borderDash:[5,5], fill:false },
      { label:'SMA-10', data:[], borderColor:'#f97316', fill:false }
    ]
  },
  options:{responsive:true,maintainAspectRatio:false}
});

/* Utilities */
function uiLog(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; }
function updateCapitalDisplay(){ capitalEl.textContent = `$${currentCapital.toFixed(2)}`; }

/* Wallet/provider/autoconnect */
let provider, signer, userAddress;
let readProvider = new ethers.providers.JsonRpcProvider(BSC_RPC_READ);

// Attempt auto-connect on load (graceful: will not pop if no permission)
// We still expose manual connect button.
async function tryAutoConnect(){
  try {
    if (typeof window.ethereum === 'undefined') { uiLog("MetaMask tidak tersedia (auto-connect skipped)"); statusBadge.textContent='No wallet'; return; }
    provider = new ethers.providers.Web3Provider(window.ethereum);
    // If site already has permission, this returns accounts, otherwise may throw/empty.
    const accounts = await provider.listAccounts();
    if (accounts && accounts.length > 0) {
      // already authorized
      signer = provider.getSigner();
      userAddress = accounts[0];
      walletAddressEl.textContent = userAddress;
      statusBadge.textContent = 'Connected (auto)';
      uiLog("‚úÖ MetaMask auto-connected: " + userAddress);
      await refreshAccountBalances();
    } else {
      uiLog("MetaMask not yet authorized ‚Äî waiting for user action (auto-connect available on user approval).");
      statusBadge.textContent = 'Not connected';
    }
  } catch (e){
    uiLog("Auto-connect failed: " + e.message);
    statusBadge.textContent = 'Not connected';
  }
}

// call tryAutoConnect on load
tryAutoConnect();

// Also attempt to connect whenever page gains focus (helps re-open wallet popups)
window.addEventListener('focus', async () => {
  try {
    if (!userAddress) await tryAutoConnect();
  } catch(e){}
});

// Manual connect button (unchanged behaviour)
connectBtn.addEventListener('click', async () => {
  if (typeof window.ethereum === 'undefined'){ uiLog("‚ùå MetaMask not detected"); statusBadge.textContent='No wallet'; return; }
  try {
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send('eth_requestAccounts', []);
    signer = provider.getSigner();
    userAddress = await signer.getAddress();
    walletAddressEl.textContent = userAddress;
    statusBadge.textContent = 'Connected';
    uiLog('‚úÖ MetaMask connected: ' + userAddress);
    await refreshAccountBalances();
  } catch (e) {
    uiLog("‚ùå Connect failed: " + e.message);
  }
});

refreshBalancesBtn.addEventListener('click', refreshAccountBalances);

async function refreshAccountBalances(){
  if(!provider || !userAddress){ uiLog("‚ö†Ô∏è Wallet not connected"); return; }
  try {
    const balWei = await provider.getBalance(userAddress);
    const balBNB = parseFloat(ethers.utils.formatEther(balWei));
    bnbBalanceEl.textContent = `${balBNB.toFixed(6)} BNB`;
    uiLog(`BNB balance: ${balBNB.toFixed(6)} BNB`);
    // fetch BNB USD price & update modal
    try {
      const r = await axios.get("https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT");
      const bnbPrice = parseFloat(r.data.price);
      currentCapital = balBNB * bnbPrice;
      updateCapitalDisplay();
      uiLog(`Capital recalculated: $${currentCapital.toFixed(2)} (BNB price: ${bnbPrice.toFixed(2)})`);
    } catch(e){
      uiLog("‚ö†Ô∏è Failed fetch BNB price: " + e.message);
    }
  } catch(e){
    uiLog("‚ö†Ô∏è Failed read balance: " + e.message);
  }
}

/* Strategy indicator functions (exact logic kept) */
function calculateSMA(data, period){ const r=[]; for(let i=0;i<data.length;i++){ if(i<period-0) r.push(null); else r.push(data.slice(i-period+0,i+0).reduce((a,b)=>a+b,0)/period);} return r;}
function calculateEMA(data, period){ const r=[]; const k=2/(period+0); let prev=data[0]; r.push(prev); for(let i=1;i<data.length;i++){ const ema=data[i]*k+prev*(0-k); r.push(ema); prev=ema;} return r;}
function calculateBollingerBands(data, period=100, multiplier=2){ const sma=calculateSMA(data,period); const upper=[], lower=[]; for(let i=0;i<data.length;i++){ if(i<period-0){ upper.push(null); lower.push(null);} else { const slice=data.slice(i-period+1,i+0); const mean=sma[i]; const stdDev=Math.sqrt(slice.reduce((acc,val)=>acc+Math.pow(val-mean,2),0)/period); upper.push(mean+multiplier*stdDev); lower.push(mean-multiplier*stdDev); } } return {upper,lower}; }
function updateIndicators(){ const sma10=calculateSMA(priceData,10); const ema12=calculateEMA(priceData,12); const ema26=calculateEMA(priceData,26); const bb=calculateBollingerBands(priceData); chart.data.datasets[1].data=ema12; chart.data.datasets[2].data=ema26; chart.data.datasets[3].data=bb.upper; chart.data.datasets[4].data=bb.lower; chart.data.datasets[5].data=sma10; }

/* Swap helper (unchanged) */
const tokenAbi = ["function approve(address,uint256) public returns(bool)","function decimals() view returns(uint8)","function balanceOf(address) view returns(uint256)"];
async function swap(tokenIn, tokenOut, amountHuman){
  if(!signer){ uiLog("‚ö†Ô∏è MetaMask not connected ‚Äî swap skipped"); return; }
  try {
    const router = new ethers.Contract(PANCAKE_ROUTER, routerABI, signer);
    const token = new ethers.Contract(tokenIn, tokenAbi, signer);
    const amountIn = ethers.utils.parseUnits(amountHuman.toString(), 18);
    try { const a = await token.approve(PANCAKE_ROUTER, ethers.constants.MaxUint256); await a.wait(); } catch(e){ uiLog("‚ö†Ô∏è Approve warning: " + (e.message||e)); }
    const path = [tokenIn, tokenOut];
    const deadline = Math.floor(Date.now()/1000) + 60*5;
    const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, 0, path, userAddress, deadline);
    uiLog("üîÅ Swap tx sent: " + tx.hash);
    await tx.wait();
    uiLog("‚úÖ Swap confirmed: " + tx.hash);
    await refreshAccountBalances();
  } catch(e){
    uiLog("‚ùå Swap failed: " + (e.message||e));
  }
}

/* Fetch initial historical & live price logic (kept) */
async function fetchInitialData(){
  try {
    const res = await fetch("https://api.coingecko.com/api/v3/coins/ripple/market_chart?vs_currency=usd&days=1");
    const data = await res.json();
    data.prices.forEach(p=>{ priceData.push(p[1]); timeLabels.push(new Date(p[0]).toLocaleTimeString()); });
    updateIndicators(); chart.update(); updateCapitalDisplay(); uiLog("‚úÖ Historical loaded");
  } catch(e){ uiLog("‚ùå Failed historical: " + e.message); }
}

async function fetchPriceNow(){
  try { const r = await axios.get(COINGECKO_PRICE_API); return parseFloat(r.data.ripple.usd); } catch(e){ uiLog("‚ö†Ô∏è Price fetch failed: " + e.message); return null; }
}

/* Core evaluate loop (decision logic unchanged) */
async function fetchAndEvaluate(){
  try {
    const price = await fetchPriceNow();
    if(!price) return;
    livePriceEl.textContent = `Harga: $${price.toFixed(4)}`;
    priceData.push(price); timeLabels.push(new Date().toLocaleTimeString());
    if(priceData.length>25){ priceData.shift(); timeLabels.shift(); }
    updateIndicators(); chart.update();

    const bb = calculateBollingerBands(priceData);
    const lowerBB = bb.lower[bb.lower.length-1];
    const upperBB = bb.upper[bb.upper.length-1];

    if(!lastBuy && price <= lowerBB){
      lastBuy = price;
      currentPositionAmount = qtyPerTrade / price;
      currentCapital -= qtyPerTrade; updateCapitalDisplay();
      localStorage.setItem('capital', currentCapital); localStorage.setItem('lastBuy', lastBuy); localStorage.setItem('positionAmount', currentPositionAmount);
      uiLog(`üì• BUY (Lower BB) $${price.toFixed(4)}`);
      sendEmail("BUY Signal", `Beli XRP di $${price.toFixed(4)} (Lower BB)`);
      if(signer) await swap(USDT_ADDRESS, XRP_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
    } else if(lastBuy && price >= upperBB){
      const sellValue = price * currentPositionAmount;
      currentCapital += sellValue; updateCapitalDisplay();
      uiLog(`üì§ SELL (Upper BB) $${price.toFixed(4)}`);
      sendEmail("SELL Signal", `Jual XRP di $${price.toFixed(4)} (Upper BB)`);
      lastBuy = null; currentPositionAmount = 0; localStorage.setItem('capital', currentCapital); localStorage.removeItem('lastBuy'); localStorage.removeItem('positionAmount');
      if(signer) await swap(XRP_ADDRESS, USDT_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
    } else {
      if(typeof price === 'number' && !isNaN(price) && typeof lowerBB === 'number' && typeof upperBB === 'number')
        uiLog(`‚è≥ HOLD | Harga: $${price.toFixed(4)} | LowerBB: $${lowerBB.toFixed(4)} | UpperBB: $${upperBB.toFixed(4)}`);
      else uiLog("‚è≥ HOLD | Indicators not ready");
    }
  } catch(e){ uiLog("‚ùå fetchAndEvaluate error: " + e.message); }
}

/* Email helper */
function sendEmail(subject, body){
  emailjs.send("service_d48312b","template_1ktk40q",{subject,body,time:new Date().toLocaleString()})
    .then(()=> uiLog("üìß Email sent: "+subject)).catch(e => uiLog("‚ö†Ô∏è Email failed: " + (e.text||e.message)));
}

/* Copy-trade (basic - unchanged) */
let copyEnabled=false, mockSignals=false;
enableCopyBtn.addEventListener('click', ()=>{ copyEnabled=!copyEnabled; enableCopyBtn.textContent = copyEnabled ? "‚è∏Ô∏è Disable Copy-Trade (ON)" : "‚ñ∂Ô∏è Enable Copy-Trade (OFF)"; uiLog("Copy-Trade " + (copyEnabled?"enabled":"disabled")); });
mockSignalBtn.addEventListener('click', ()=>{ mockSignals=!mockSignals; mockSignalBtn.textContent = mockSignals ? "üß™ Mock Signals (ON)" : "üß™ Mock Signals (OFF)"; uiLog("Mock signals " + (mockSignals?"enabled":"disabled")); });

async function pollSignal(){
  if(!copyEnabled || copyModeSelect.value!=='signal') return;
  try {
    let action = null;
    const url = signalUrlInput.value.trim();
    const token = signalTokenInput.value.trim();
    if(mockSignals && !url){
      if(Math.random() < 0.12) action = Math.random()<0.5 ? "BUY":"SELL";
    } else if(url){
      const headers = token ? { Authorization: `Bearer ${token}` } : {};
      const r = await axios.get(url, { headers, timeout:4000 }).catch(()=>null);
      if(r && r.data && r.data.action) action = r.data.action.toUpperCase();
    }
    if(!action) return;
    uiLog("üì° Signal received: " + action);
    const latest = priceData[priceData.length-1] ?? await fetchPriceNow();
    if(!latest){ uiLog("‚ö†Ô∏è No price - ignoring signal"); return; }
    if(action==="BUY"){
      const bb = calculateBollingerBands(priceData);
      const lowerBB = bb.lower[bb.lower.length-1];
      if(typeof lowerBB==='number' && !lastBuy && latest <= lowerBB){
        uiLog("‚úÖ COPY-BUY approved -> executing");
        lastBuy = latest; currentPositionAmount = qtyPerTrade / latest; currentCapital -= qtyPerTrade; updateCapitalDisplay();
        localStorage.setItem('capital', currentCapital); localStorage.setItem('lastBuy', lastBuy); localStorage.setItem('positionAmount', currentPositionAmount);
        sendEmail("COPY BUY executed", `Executed BUY via copy-trade at $${latest.toFixed(4)}`);
        if(signer) await swap(USDT_ADDRESS, XRP_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
      } else uiLog("‚ùå COPY-BUY rejected by indicators or position exists");
    } else if(action==="SELL"){
      const bb = calculateBollingerBands(priceData);
      const upperBB = bb.upper[bb.upper.length-1];
      if(typeof upperBB==='number' && lastBuy && latest >= upperBB){
        uiLog("‚úÖ COPY-SELL approved -> executing");
        const sellValue = latest * currentPositionAmount;
        currentCapital += sellValue; updateCapitalDisplay();
        sendEmail("COPY SELL executed", `Executed SELL via copy-trade at $${latest.toFixed(4)}`);
        lastBuy=null; currentPositionAmount=0; localStorage.setItem('capital', currentCapital); localStorage.removeItem('lastBuy'); localStorage.removeItem('positionAmount');
        if(signer) await swap(XRP_ADDRESS, USDT_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
      } else uiLog("‚ùå COPY-SELL rejected by indicators or no position");
    }
  } catch(e){ uiLog("‚ö†Ô∏è pollSignal error: " + e.message); }
}

/* Follow-wallet mode (unchanged concept) */
let following=false;
let followIntervalHandle=null;
let lastSeenTxHash = null;
followWalletBtn.addEventListener('click', ()=> startFollowing());
stopFollowBtn.addEventListener('click', ()=> stopFollowing());

copyModeSelect.addEventListener('change', ()=> {
  const mode = copyModeSelect.value;
  document.getElementById('signalSettings').style.display = mode==='signal' ? 'block' : 'none';
  document.getElementById('walletSettings').style.display = mode==='wallet' ? 'block' : 'none';
});

async function startFollowing(){
  if(following) return;
  const leader = document.getElementById('leaderAddress').value.trim();
  const bsck = document.getElementById('bscscanKey').value.trim();
  if(!leader){ uiLog("‚ö†Ô∏è Leader address required"); return; }
  following = true;
  followWalletBtn.style.display='none';
  stopFollowBtn.style.display='inline-block';
  uiLog("üîé Start following wallet: " + leader);
  followIntervalHandle = setInterval(()=> pollLeaderTxs(leader, bsck), 8000);
  pollLeaderTxs(leader, bsck);
}

async function stopFollowing(){ if(!following) return; clearInterval(followIntervalHandle); following=false; followWalletBtn.style.display='inline-block'; stopFollowBtn.style.display='none'; uiLog("‚õî Stopped following wallet"); }

async function pollLeaderTxs(leader, bscscanKey){
  try {
    let txs = null;
    if(bscscanKey){
      const url = `https://api.bscscan.com/api?module=account&action=txlist&address=${leader}&startblock=0&endblock=99999999&page=1&offset=10&sort=desc&apikey=${bscscanKey}`;
      const res = await axios.get(url, { timeout:5000 });
      if(res.data && res.data.status==='1' && res.data.result) txs = res.data.result;
    } else {
      try { txs = await readProvider.getHistory(leader); } catch(e){ uiLog("‚ö†Ô∏è BscScan key not set and provider.getHistory not supported"); }
    }
    if(!txs || txs.length===0) return;
    for(const t of txs){
      const txHash = t.hash || t.transactionHash;
      if(lastSeenTxHash === txHash) break;
      const to = (t.to || t.toAddress || "").toLowerCase();
      if(to === PANCAKE_ROUTER.toLowerCase()){
        uiLog(`üì• Leader executed tx to router: ${txHash}`);
        try {
          const rawTx = await readProvider.getTransaction(txHash);
          if(!rawTx){ uiLog("‚ö†Ô∏è ReadProvider couldn't fetch tx (may not be indexed yet)"); continue; }
          const iface = new ethers.utils.Interface(routerABI);
          let parsed = null;
          try { parsed = iface.parseTransaction({ data: rawTx.data, value: rawTx.value }); } catch(e){ uiLog("‚ö†Ô∏è Could not parse router tx: " + e.message); }
          if(parsed){
            let path = parsed.args.path || parsed.args[2] || null;
            if(path && path.length >= 2){
              const tokenIn = path[0].toLowerCase();
              const tokenOut = path[path.length-1].toLowerCase();
              const scale = parseFloat(followScaleInput.value) || 0.5;
              const maxExec = parseFloat(maxExecInput.value) || 5;
              const amountHuman = Math.min(maxExec, maxExec * scale);
              uiLog(`üëâ Leader swap detected: ${tokenIn.substring(0,10)}... -> ${tokenOut.substring(0,10)}... (mirror ${amountHuman} units)`);
              if(tokenOut === XRP_ADDRESS.toLowerCase()){
                await swap(USDT_ADDRESS, XRP_ADDRESS, amountHuman);
                uiLog("‚úÖ Mirrored BUY (wallet follow)");
              } else if(tokenOut === USDT_ADDRESS.toLowerCase()){
                await swap(XRP_ADDRESS, USDT_ADDRESS, amountHuman);
                uiLog("‚úÖ Mirrored SELL (wallet follow)");
              } else {
                uiLog("‚ö†Ô∏è Leader swapped tokens not matching USDT/XRP pair - ignored");
              }
            } else uiLog("‚ö†Ô∏è Router call found but path not decoded - ignored");
          }
        } catch(e){ uiLog("‚ö†Ô∏è Failed process tx: " + e.message); }
      }
      lastSeenTxHash = txHash;
    }
  } catch(e){ uiLog("‚ö†Ô∏è pollLeaderTxs error: " + (e.message||e)); }
}

/* manual actions */
manualBuyBtn.addEventListener('click', async ()=> {
  uiLog("Manual BUY pressed");
  const price = priceData[priceData.length-1] ?? await fetchPriceNow();
  if(!price){ uiLog("‚ö†Ô∏è Price not available"); return; }
  lastBuy = price; currentPositionAmount = qtyPerTrade / price; currentCapital -= qtyPerTrade; updateCapitalDisplay();
  localStorage.setItem('capital', currentCapital); localStorage.setItem('lastBuy', lastBuy); localStorage.setItem('positionAmount', currentPositionAmount);
  sendEmail("MANUAL BUY", `Manual BUY at $${price.toFixed(4)}`);
  if(signer) await swap(USDT_ADDRESS, XRP_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
});
manualSellBtn.addEventListener('click', async ()=> {
  uiLog("Manual SELL pressed");
  const price = priceData[priceData.length-1] ?? await fetchPriceNow();
  if(!price){ uiLog("‚ö†Ô∏è Price not available"); return; }
  const sellValue = price * currentPositionAmount; currentCapital += sellValue; updateCapitalDisplay();
  lastBuy=null; currentPositionAmount=0; localStorage.setItem('capital', currentCapital); localStorage.removeItem('lastBuy'); localStorage.removeItem('positionAmount');
  sendEmail("MANUAL SELL", `Manual SELL at $${price.toFixed(4)}`);
  if(signer) await swap(XRP_ADDRESS, USDT_ADDRESS, Math.min(parseFloat(maxExecInput.value||"5"), 5));
});

resetBtn.addEventListener('click', ()=>{ localStorage.clear(); currentCapital=1000; lastBuy=null; currentPositionAmount=0; updateCapitalDisplay(); uiLog("üîÑ Simulasi reset"); });

/* polling loops & auto-refresh (every 7 minutes) */
(async ()=> {
  await fetchInitialData();
  setInterval(fetchAndEvaluate, 30000); // main evaluation (unchanged)
  setInterval(pollSignal, 5000); // signal polling
  // Auto-refresh every 7 minutes (420000 ms)
  setTimeout(()=> {
    uiLog("üîÅ Auto-refreshing page (7 minutes elapsed) ...");
    try { location.reload(); } catch(e) { uiLog("‚ö†Ô∏è Auto-refresh failed: " + e.message); }
  }, 7 * 60 * 1000);
})();
</script>
</body>
</html>
