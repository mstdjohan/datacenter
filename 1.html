<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>XRPUSDT Auto Signals (100R + LRC + UTBot)</title>
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body { background:#111; color:#eee; font-family: Arial; }
    #chart { height: 500px; }
  </style>
</head>
<body>
  <h2>XRPUSDT â€” Range 100R + LRC + UT Bot</h2>
  <div id="chart"></div>
  <pre id="log"></pre>

<script>
// --- Logger ---
const log = (msg) => {
  const ts = new Date().toLocaleTimeString();
  document.getElementById("log").textContent += `[${ts}] ${msg}\n`;
};

// --- Init Chart ---
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout: { background: { color: '#111' }, textColor: '#ddd' },
  grid: { vertLines: { color: '#333' }, horzLines: { color: '#333' } },
});
const candleSeries = chart.addCandlestickSeries();
const markers = [];

// --- Data buffer ---
let candles = [];
let currentCandle = null;
const RANGE_SIZE = 100; // 100R

// --- Linear Regression ---
function linearRegression(data, length=100) {
  if (data.length < length) return null;
  const slice = data.slice(-length);
  const n = slice.length;
  let sumX=0,sumY=0,sumXY=0,sumX2=0;
  for (let i=0;i<n;i++) {
    sumX += i;
    sumY += slice[i].close;
    sumXY += i*slice[i].close;
    sumX2 += i*i;
  }
  const slope = (n*sumXY - sumX*sumY)/(n*sumX2 - sumX*sumX);
  const intercept = (sumY - slope*sumX)/n;
  return slice.map((c,i)=>({time:c.time,value:intercept+slope*i}));
}

// --- ATR (for UT Bot) ---
function calcATR(data, length=14) {
  if (data.length < length+1) return null;
  let trs=[];
  for (let i=1;i<data.length;i++) {
    const high=data[i].high, low=data[i].low, closePrev=data[i-1].close;
    trs.push(Math.max(high-low, Math.abs(high-closePrev), Math.abs(low-closePrev)));
  }
  let atr=trs.slice(-length).reduce((a,b)=>a+b,0)/length;
  return atr;
}

// --- UT Bot Alerts ---
let trend=null;
function utBotSignal(data, atrPeriod=2, factor=10) {
  if (data.length < atrPeriod+2) return null;
  const atr = calcATR(data, atrPeriod);
  if (!atr) return null;
  const last = data[data.length-1];
  const prev = data[data.length-2];
  const buyLine = prev.close - factor*atr;
  const sellLine = prev.close + factor*atr;

  if (last.close > sellLine && trend!=="buy") {
    trend="buy"; return {type:"buy", price:last.close, time:last.time};
  }
  if (last.close < buyLine && trend!=="sell") {
    trend="sell"; return {type:"sell", price:last.close, time:last.time};
  }
  return null;
}

// --- Update Candle (simulate 100R range) ---
function updatePrice(price) {
  const t = Math.floor(Date.now()/1000);
  if (!currentCandle) {
    currentCandle = {time:t, open:price, high:price, low:price, close:price};
    return;
  }
  currentCandle.high = Math.max(currentCandle.high, price);
  currentCandle.low = Math.min(currentCandle.low, price);
  currentCandle.close = price;

  if (Math.abs(currentCandle.close - currentCandle.open) >= RANGE_SIZE) {
    candles.push(currentCandle);
    candleSeries.setData(candles);

    // Signals
    const sig = utBotSignal(candles,2,10);
    if (sig) {
      markers.push({
        time:sig.time,
        position:sig.type==="buy"?"belowBar":"aboveBar",
        color:sig.type==="buy"?"#0f0":"#f00",
        shape:"arrow"+(sig.type==="buy"?"Up":"Down"),
        text:sig.type.toUpperCase()
      });
      candleSeries.setMarkers(markers);
      log(`Signal ${sig.type.toUpperCase()} at ${sig.price}`);
    }

    currentCandle=null;
  }
}

// --- Fetch price from Binance ---
const ws = new WebSocket("wss://stream.binance.com:9443/ws/xrpusdt@trade");
ws.onmessage = (ev) => {
  const trade = JSON.parse(ev.data);
  const price = parseFloat(trade.p);
  updatePrice(price);
};

</script>
</body>
</html>
