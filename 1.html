<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AutoBot CAKE/USDT — EmailJS Integrated (Fixed)</title>
  <style>
    :root{--card:#fff;--bg:#fffaf2;--text:#1e1b16}
    body{font-family:Inter,ui-sans-serif,system-ui;background:linear-gradient(#fff7e6,#fff);color:var(--text);margin:0;padding:20px}
    .wrap{max-width:1200px;margin:0 auto}
    .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:12px;border:1px solid #eee}
    .row{display:grid;grid-template-columns:1.6fr 1fr;gap:12px}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    button{padding:8px 12px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:#111;color:#fff}
    .btn-buy{background:#2563eb;color:#fff}
    .btn-sell{background:#f59e0b;color:#fff}
    .log{height:220px;overflow:auto;font-family:monospace;font-size:12px;background:#fafafa;padding:8px;border-radius:8px}
    #lwchart{height:420px}
    .pill{background:#fff;padding:6px 10px;border-radius:999px;border:1px solid #e6e6e6}
    .small{font-size:13px;color:#666}
  </style>

  <!-- Ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
  <!-- TradingView widget -->
  <script src="https://s3.tradingview.com/tv.js"></script>
  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
  <!-- EmailJS SDK -->
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2>AutoBot — CAKE/USDT · EmailJS Integrated (FINAL)</h2>
      <div class="small">Fitur: UT-Bot signal -> kirim email langsung, konfirmasi -> kirim email konfirmasi, eksekusi -> kirim email eksekusi.</div>
      <div class="small" style="margin-top:8px;color:#a00">Jalankan via HTTP server (contoh: <code>python -m http.server 8000</code>) agar fetch Binance tidak diblok.</div>
    </div>

    <div class="row">
      <div>
        <div class="card">
          <div id="tvwrap" style="height:300px;border-radius:8px;overflow:hidden;margin-bottom:10px">
            <div id="tv_chart" style="height:100%;width:100%"></div>
          </div>

          <div id="lwchart" class="card"></div>

          <div class="card">
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <button id="btnConnect" class="btn-primary">Connect (MetaMask/Trust)</button>
              <span class="pill">Addr: <span id="addr">—</span></span>
              <button id="btnAuto" class="btn-primary">Start Auto</button>
              <button id="btnBuy" class="btn-buy">Manual BUY</button>
              <button id="btnSell" class="btn-sell">Manual SELL</button>
              <label class="pill"><input id="paper" type="checkbox" checked /> Paper mode</label>
            </div>

            <div class="controls" style="margin-top:12px">
              <div>
                <label>BASE (USDT)</label>
                <input id="base" value="0x55d398326f99059fF775485246999027B3197955" />
              </div>
              <div>
                <label>TOKEN (CAKE)</label>
                <input id="token" value="0x0E09FABB73BD3ADE0A17ECC321FD13A19E81CE82" />
              </div>
              <div>
                <label>Symbol (Binance)</label>
                <select id="symbol"><option value="CAKEUSDT" selected>CAKEUSDT</option></select>
              </div>
              <div>
                <label>Interval</label>
                <select id="interval"><option value="5m" selected>5m</option><option value="15m">15m</option><option value="1m">1m</option></select>
              </div>
              <div>
                <label>Bars keep</label>
                <input id="barsKeep" type="number" value="600" />
              </div>
              <div>
                <label>Slippage (e.g. 0.1)</label>
                <input id="slippage" value="0.1" />
              </div>
              <div>
                <label>UT ATR</label>
                <input id="utAtr" type="number" value="1" />
              </div>
              <div>
                <label>UT Factor</label>
                <input id="utFactor" type="number" value="10" />
              </div>
            </div>
          </div>

          <div class="card">
            <div class="log" id="logs"></div>
          </div>
        </div>
      </div>

      <div>
        <div class="card">
          <h3>Execution Rules</h3>
          <ol>
            <li>BUY: UTBot=buy & price ≤ LRC lower & RSI &lt; 30.</li>
            <li>SELL: UTBot=sell OR price ≥ LRC upper & RSI &gt; 70.</li>
            <li>Amount: 100% dari saldo (USDT untuk buy, CAKE untuk sell).</li>
          </ol>
        </div>

        <div class="card">
          <h3>EmailJS</h3>
          <div class="small">Service / template / user id sudah diisi sesuai permintaan.</div>
          <div style="margin-top:8px">
            <b>Service ID:</b> <span id="cfg_svc">service_d48312b</span><br>
            <b>Template ID:</b> <span id="cfg_tmpl">template_1ltk40q</span><br>
            <b>User ID:</b> <span id="cfg_user">aPZx0R9oxUbIQkLEv</span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(async () => {

  // ---- Config (from your confirmation) ----
  const EMAILJS_SERVICE_ID = "service_d48312b";
  const EMAILJS_TEMPLATE_ID = "template_1ltk40q";
  const EMAILJS_PUBLIC_KEY = "aPZx0R9oxUbIQkLEv"; // public key (user id)

  // initialize EmailJS
  try {
    if (window.emailjs && typeof emailjs.init === 'function') {
      emailjs.init(EMAILJS_PUBLIC_KEY);
      log('EmailJS initialized (public key set)');
    } else {
      log('EmailJS SDK not ready');
    }
  } catch(e){ log('EmailJS init error: '+(e.message||e)); }

  // --- imports from ethers UMD
  const { BrowserProvider, JsonRpcProvider, Contract, getAddress } = window.ethers;
  // Pancake router / ABIs etc. (same as your script)
  const PCS_V2_ROUTER = getAddress("0x10ED43C718714eb63d5aA57B78B54704E256024E");
  const DEFAULT_RPC = "https://bsc-dataseed.binance.org";
  const ROUTER_ABI = [
    "function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory amounts)",
    "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)",
  ];
  const ERC20_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];

  // DOM helpers
  const $ = id => document.getElementById(id);
  const elAddr = $('addr'), elLogs = $('logs');
  const btnConnect = $('btnConnect'), btnAuto = $('btnAuto'), btnBuy = $('btnBuy'), btnSell = $('btnSell');
  const elBase = $('base'), elToken = $('token'), elPaper = $('paper'), elSlippage = $('slippage');
  const elSymbol = $('symbol'), elInterval = $('interval'), elBarsKeep = $('barsKeep');
  const elUtAtr = $('utAtr'), elUtFactor = $('utFactor');

  // provider / signer
  const readProvider = new JsonRpcProvider(DEFAULT_RPC);
  let walletProvider = null, signer = null, address = null;

  // Lightweight chart
  let lwc = null, candleSeries = null, upperLine=null, lowerLine=null, midLine=null, trailLine=null;
  function createChart(){
    try{
      if(!document.getElementById('lwchart')) return;
      if(lwc) return; // already
      lwc = LightweightCharts.createChart(document.getElementById('lwchart'), {
        layout:{ background:{ type: 'solid', color: '#ffffff' }, textColor:'#222' },
        rightPriceScale:{ borderVisible:false }, timeScale:{ borderVisible:false }, grid:{ vertLines:{ color:'#eee' }, horzLines:{ color:'#eee' } }
      });
      candleSeries = lwc.addCandlestickSeries();
      upperLine = lwc.addLineSeries({ lineWidth:1 });
      lowerLine = lwc.addLineSeries({ lineWidth:1 });
      midLine = lwc.addLineSeries({ lineWidth:2 });
      trailLine = lwc.addLineSeries({ lineWidth:1, lineStyle:3 });
      log('Lightweight chart created');
    }catch(e){ log('createChart error: '+(e.message||e)); }
  }

  // state
  let bars = [];
  let polling = null;
  let auto = false;
  let isHolding = false;
  let entryPrice = null;
  let lastSignalBarTime = null; // dedupe signal email per bar

  // logging
  function log(msg){
    const time = new Date().toLocaleTimeString();
    elLogs.textContent = `[${time}] ${msg}\n` + elLogs.textContent;
    console.log('[LOG] '+msg);
  }

  // TA helpers (kept from your script)
  function linearRegression(y){ const n=y.length; if(!n) return {slope:0,intercept:0}; let sx=0,sy=0,sxy=0,sxx=0; for(let i=0;i<n;i++){ const x=i+1; const v=y[i]; sx+=x; sy+=v; sxy+=x*v; sxx+=x*x;} const d=(n*sxx - sx*sx)||1e-12; const slope=(n*sxy - sx*sy)/d; const intercept=(sy - slope*sx)/n; return {slope,intercept}; }
  function stdev(vals){ const n=vals.length; if(!n) return 0; const m=vals.reduce((a,b)=>a+b,0)/n; const v=vals.reduce((acc,x)=>acc+(x-m)*(x-m),0)/n; return Math.sqrt(v); }
  function computeLRC_Open(bars, length=100, devUp=2, devDn=2){
    const opens = bars.map(b=>b.open); const n=opens.length;
    const mid=Array(n).fill(null), upper=Array(n).fill(null), lower=Array(n).fill(null);
    if(n<length) return {mid,upper,lower};
    for(let i=length-1;i<n;i++){
      const win=opens.slice(i-length+1,i+1);
      const {slope,intercept}=linearRegression(win);
      const xLast = length;
      const midVal = slope*xLast + intercept;
      const resid = win.map((v,idx)=>v - (slope*(idx+1) + intercept));
      const sd = stdev(resid);
      mid[i]=midVal; upper[i]=midVal + devUp*sd; lower[i]=midVal - devDn*sd;
    }
    return {mid,upper,lower};
  }
  function computeATR(ohlc, period=1){
    if(ohlc.length<2) return Array(ohlc.length).fill(null);
    const trs=[]; for(let i=1;i<ohlc.length;i++){ const h=ohlc[i].high, l=ohlc[i].low, pc=ohlc[i-1].close; trs.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))); }
    const atr=[]; let ema=null; const k=2/(period+1);
    for(let i=0;i<trs.length;i++){ if(i===0) ema=trs[0]; else ema=k*trs[i] + (1-k)*ema; atr.push(ema); }
    return [null, ...atr];
  }
  function computeUTBotSignals(ohlc, atrPeriod=1, factor=10){
    const atrArr = computeATR(ohlc, atrPeriod);
    const signals = new Array(ohlc.length).fill(null);
    const trail = new Array(ohlc.length).fill(null);
    if(ohlc.length===0) return {signals, trail};
    let trend = 0; let ts = null;
    for(let i=0;i<ohlc.length;i++){
      const c = ohlc[i].close; const atr = atrArr[i] ?? 0;
      const buyTs = c - factor*atr; const sellTs = c + factor*atr;
      if (i===0){ ts = buyTs; trail[i]=ts; trend=1; continue; }
      if (trend >= 0){
        ts = ts == null ? buyTs : Math.max(ts, buyTs); trail[i] = ts;
        if (c < ts){ trend = -1; signals[i] = 'sell'; ts = sellTs; trail[i]=ts; } else trend = 1;
      } else {
        ts = ts == null ? sellTs : Math.min(ts, sellTs); trail[i] = ts;
        if (c > ts){ trend = 1; signals[i] = 'buy'; ts = buyTs; trail[i]=ts; } else trend = -1;
      }
    }
    return {signals, trail};
  }
  function computeRSI(ohlc, period=14){
    if (ohlc.length <= period) return Array(ohlc.length).fill(null);
    const rsi = Array(ohlc.length).fill(null);
    let gains = 0, losses = 0;
    for (let i = 1; i <= period; i++){
      const diff = ohlc[i].close - ohlc[i-1].close;
      if (diff > 0) gains += diff; else losses += -diff;
    }
    let avgGain = gains / period, avgLoss = losses / period;
    rsi[period] = avgLoss === 0 ? 100 : 100 - 100/(1 + (avgGain/avgLoss));
    for (let i = period+1; i < ohlc.length; i++){
      const diff = ohlc[i].close - ohlc[i-1].close;
      const gain = diff > 0 ? diff : 0;
      const loss = diff < 0 ? -diff : 0;
      avgGain = (avgGain*(period-1) + gain)/period;
      avgLoss = (avgLoss*(period-1) + loss)/period;
      rsi[i] = avgLoss === 0 ? 100 : 100 - 100/(1 + (avgGain/avgLoss));
    }
    return rsi;
  }

  // helpers to map to LightWeight series
  function toSeries(arr){
    return bars.map((b,i)=> arr[i]==null? null: { time: Math.floor(b.t/1000), value: arr[i] }).filter(Boolean);
  }

  // render
  function renderAll(){
    if(!candleSeries) createChart();
    const cand = bars.map(b=>({ time: Math.floor(b.t/1000), open:b.open, high:b.high, low:b.low, close:b.close }));
    try{ candleSeries.setData(cand); }catch(e){ log('setData error: '+(e.message||e)); }
    const lrc = computeLRC_Open(bars, 100, 2, 2);
    const ut = computeUTBotSignals(bars, Number(elUtAtr.value||1), Number(elUtFactor.value||10));
    if(upperLine) upperLine.setData(toSeries(lrc.upper));
    if(lowerLine) lowerLine.setData(toSeries(lrc.lower));
    if(midLine) midLine.setData(toSeries(lrc.mid));
    if(trailLine) trailLine.setData(toSeries(ut.trail));
    const markers = [];
    for (let i=0;i<bars.length;i++){
      if (!ut.signals[i]) continue;
      markers.push({ time: Math.floor(bars[i].t/1000), position: ut.signals[i]==='buy' ? 'belowBar' : 'aboveBar', color: ut.signals[i]==='buy' ? 'green' : 'red', shape: ut.signals[i]==='buy' ? 'arrowUp' : 'arrowDown', text: ut.signals[i].toUpperCase() });
    }
    try{ candleSeries.setMarkers(markers); }catch(e){ /* ignore marker set errors */ }
  }

  // Binance fetch
  const BINANCE_BASE = "https://api.binance.com/api/v3";
  const intervalMap = {"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h"};
  async function fetchInitial(symbol, interval, limit=600){
    const url = `${BINANCE_BASE}/klines?symbol=${symbol}&interval=${intervalMap[interval]||interval}&limit=${limit}`;
    const res = await fetch(url); if(!res.ok) throw new Error('Klines fetch failed: '+res.status);
    const arr = await res.json();
    return arr.map(k=>({ t: k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4] }));
  }
  async function fetchLatest(symbol, interval){
    const url = `${BINANCE_BASE}/klines?symbol=${symbol}&interval=${intervalMap[interval]||interval}&limit=2`;
    const res = await fetch(url); if(!res.ok) throw new Error('Klines fetch failed: '+res.status);
    const arr = await res.json();
    const k = arr[arr.length-1];
    return { t:k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4] };
  }

  // ------------ EMAIL functions --------------
  async function sendSignalEmail(side, pair, price, timeframe, mode='Signal'){
    // dedupe: only one signal email per bar
    const barTime = bars.length? Math.floor(bars[bars.length-1].t/1000) : null;
    if(barTime && lastSignalBarTime === barTime){
      log('Signal email deduped for bar: '+barTime);
      return;
    }
    lastSignalBarTime = barTime;
    const payload = {
      action: `[SIGNAL] ${side.toUpperCase()} detected`,
      pair: pair,
      price: String(price),
      mode: mode,
      time: new Date().toLocaleString(),
      interval: timeframe
    };
    try{
      if(window.emailjs && EMAILJS_SERVICE_ID && EMAILJS_TEMPLATE_ID){
        await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, payload);
        log(`Signal email sent (${side})`);
      } else {
        log('EmailJS not ready — signal email skipped (preview): '+ JSON.stringify(payload));
      }
    }catch(e){ log('Signal email error: '+(e.text||e.message||e)); }
  }

  async function sendConfirmEmail(side, pair, price, timeframe, mode='Confirm'){
    const payload = {
      action: `[CONFIRM] ${side.toUpperCase()} confirmation`,
      pair: pair,
      price: String(price),
      mode: mode,
      time: new Date().toLocaleString(),
      interval: timeframe
    };
    try{
      if(window.emailjs && EMAILJS_SERVICE_ID && EMAILJS_TEMPLATE_ID){
        await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, payload);
        log(`Confirm email sent (${side})`);
      } else {
        log('EmailJS not ready — confirm email skipped (preview): '+ JSON.stringify(payload));
      }
    }catch(e){ log('Confirm email error: '+(e.text||e.message||e)); }
  }

  async function sendExecEmail(side, pair, price, timeframe, mode='Executed', profit=''){
    const payload = {
      action: `[EXECUTED] ${side.toUpperCase()} executed`,
      pair: pair,
      price: String(price),
      mode: mode,
      time: new Date().toLocaleString(),
      interval: timeframe,
      profit: profit || ''
    };
    try{
      if(window.emailjs && EMAILJS_SERVICE_ID && EMAILJS_TEMPLATE_ID){
        await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, payload);
        log(`Exec email sent (${side})`);
      } else {
        log('EmailJS not ready — exec email skipped (preview): '+ JSON.stringify(payload));
      }
    }catch(e){ log('Exec email error: '+(e.text||e.message||e)); }
  }

  // ------------ trading helpers (simplified) --------------
  function bnToBigInt(bn){
    if (bn === null || bn === undefined) return 0n;
    try { return BigInt(bn.toString()); } catch(e){ return 0n; }
  }
  function bnToStringReadable(bn, decimals=18){
    if (bn === null || bn === undefined) return "0";
    try {
      const asBigInt = BigInt(bn.toString());
      const pow = 10n ** BigInt(decimals);
      const whole = asBigInt / pow;
      const frac = String(asBigInt % pow).padStart(decimals, '0').replace(/0+$/,'');
      return frac ? `${whole}.${frac}` : `${whole}`;
    } catch(e){ return bn.toString(); }
  }

  async function getDecimalsAndBalance(tokenAddr){
    const erc = new Contract(tokenAddr, ERC20_ABI, readProvider);
    let decimals = 18;
    try { decimals = Number(await erc.decimals().catch(()=>18)); } catch(e){ log('decimals() failed'); }
    let balRaw = 0;
    try { balRaw = await erc.balanceOf(address).catch(()=>0); } catch(e){ log('balanceOf() failed'); balRaw = 0; }
    const bal = bnToBigInt(balRaw);
    const readable = bnToStringReadable(balRaw, decimals);
    return { decimals, bal, readable, raw: balRaw };
  }

  async function ensureApproval(tokenAddr, spender, amountBig){
    if (!signer) throw new Error('Signer not ready');
    const erc = new Contract(tokenAddr, ERC20_ABI, signer);
    let allowanceRaw = 0;
    try { allowanceRaw = await erc.allowance(address, spender).catch(()=>0); } catch(e){ log('allowance() failed'); allowanceRaw = 0; }
    const allowance = bnToBigInt(allowanceRaw);
    log(`Allowance current: ${String(allowance)}`);
    if (allowance < BigInt(amountBig)) {
      log('Approving router to spend token...');
      const tx = await erc.approve(spender, BigInt(amountBig));
      log('Approve tx sent: ' + tx.hash);
      await tx.wait();
      log('Approve confirmed');
    } else {
      log('Approval sufficient');
    }
  }

  function calcOutMinBig(amountOutBig, slipFloat){
    const bps = 10000n;
    const slipBps = BigInt(Math.floor((slipFloat||0)*10000));
    return (BigInt(amountOutBig) * (bps - slipBps)) / bps;
  }

  // main executeTrade (with confirm email on prompt and exec email on success)
  async function executeTrade(direction, opts={force:false}){
    try {
      if (!signer) {
        const ok = await connectWallet();
        if (!ok) { log('Wallet not connected - abort'); return; }
      }
      const base = getAddress(String(elBase.value).trim());
      const token = getAddress(String(elToken.value).trim());
      if (!base || !token) { log('Invalid base/token'); return; }

      // paper mode simulated execution
      if (elPaper.checked) {
        const currentPrice = bars[bars.length-1].close;
        if (direction === 'buy') {
          isHolding = true; entryPrice = currentPrice;
          log(`[PAPER] BUY simulated entry=${entryPrice}`);
          // send exec email for simulated trade
          await sendExecEmail('BUY', elSymbol.value||'CAKEUSDT', entryPrice, elInterval.value||'5m', 'Paper', '');
          return;
        } else {
          const sellPrice = bars[bars.length-1].close;
          let profitText = '';
          if (entryPrice) {
            const pct = ((sellPrice - entryPrice) / entryPrice) * 100;
            profitText = (pct>=0?'+':'') + pct.toFixed(2) + '%';
          }
          isHolding = false; entryPrice = null;
          log(`[PAPER] SELL simulated price=${sellPrice} profit=${profitText}`);
          await sendExecEmail('SELL', elSymbol.value||'CAKEUSDT', sellPrice, elInterval.value||'5m', 'Paper', profitText);
          return;
        }
      }

      const router = new Contract(PCS_V2_ROUTER, ROUTER_ABI, signer);

      if (direction === 'buy' && isHolding && !opts.force) { log('BUY skipped — already holding'); return; }
      if (direction === 'sell' && !isHolding && !opts.force) { log('SELL skipped — not holding'); return; }

      if (direction === 'buy') {
        // buy: base -> token
        const {decimals, bal} = await getDecimalsAndBalance(base);
        const amountIn = bal;
        if (amountIn === 0n) { log('BUY aborted — base balance zero'); return; }

        log('Estimating amountsOut for buy...');
        const amountsOut = await router.getAmountsOut(amountIn, [base, token]).catch(e=>{ throw new Error('getAmountsOut failed: '+(e.message||e)); });
        const outRaw = amountsOut[amountsOut.length-1];
        const outBig = bnToBigInt(outRaw);
        const outDecimals = (await (new Contract(token, ERC20_ABI, readProvider)).decimals().catch(()=>18));
        const outMin = calcOutMinBig(outBig, Number(elSlippage.value||0.01));

        // prompt confirm
        const confirmMsg = `CONFIRM BUY?
Pair: ${elSymbol.value}
Estimated out: ${bnToStringReadable(outRaw, outDecimals)}
Slippage: ${elSlippage.value}
Type CONFIRM to proceed.`;
        const ok = prompt(confirmMsg,'');
        if (ok !== 'CONFIRM') { log('User cancelled BUY'); return; }

        // send confirm-email BEFORE executing (as requested)
        await sendConfirmEmail('BUY', elSymbol.value||'CAKEUSDT', bars[bars.length-1].close, elInterval.value||'5m', 'Confirm');

        await ensureApproval(base, PCS_V2_ROUTER, amountIn);
        log('Sending swapExactTokensForTokens (BUY)...');
        const tx = await router.swapExactTokensForTokens(amountIn, outMin, [base, token], address, Math.floor(Date.now()/1000)+300);
        log('BUY tx sent: '+tx.hash);
        await tx.wait();
        log('BUY confirmed: '+tx.hash);
        isHolding = true;
        entryPrice = bars[bars.length-1].close;
        // send execution email
        await sendExecEmail('BUY', elSymbol.value||'CAKEUSDT', entryPrice, elInterval.value||'5m', 'OnChain', '');
      } else {
        // sell: token -> base
        const {decimals, bal} = await getDecimalsAndBalance(token);
        const amountIn = bal;
        if (amountIn === 0n) { log('SELL aborted — token balance zero'); return; }

        log('Estimating amountsOut for sell...');
        const amountsOut = await router.getAmountsOut(amountIn, [token, base]).catch(e=>{ throw new Error('getAmountsOut failed: '+(e.message||e)); });
        const outRaw = amountsOut[amountsOut.length-1];
        const outBig = bnToBigInt(outRaw);
        const baseDecimals = (await (new Contract(base, ERC20_ABI, readProvider)).decimals().catch(()=>18));
        const outMin = calcOutMinBig(outBig, Number(elSlippage.value||0.1));

        const confirmMsg = `CONFIRM SELL?
Pair: ${elSymbol.value}
Estimated out: ${bnToStringReadable(outRaw, baseDecimals)}
Slippage: ${elSlippage.value}
Type CONFIRM to proceed.`;
        const ok = prompt(confirmMsg,'');
        if (ok !== 'CONFIRM') { log('User cancelled SELL'); return; }

        // send confirm-email BEFORE executing
        await sendConfirmEmail('SELL', elSymbol.value||'CAKEUSDT', bars[bars.length-1].close, elInterval.value||'5m', 'Confirm');

        await ensureApproval(token, PCS_V2_ROUTER, amountIn);
        log('Sending swapExactTokensForTokens (SELL)...');
        const tx = await router.swapExactTokensForTokens(amountIn, outMin, [token, base], address, Math.floor(Date.now()/1000)+300);
        log('SELL tx sent: '+tx.hash);
        await tx.wait();
        log('SELL confirmed: '+tx.hash);
        const sellPrice = bars[bars.length-1].close;
        let profitText = '';
        if (entryPrice) {
          const pct = ((sellPrice - entryPrice) / entryPrice) * 100;
          profitText = (pct>=0?'+':'') + pct.toFixed(2) + '%';
        }
        isHolding = false;
        entryPrice = null;
        await sendExecEmail('SELL', elSymbol.value||'CAKEUSDT', sellPrice, elInterval.value||'5m', 'OnChain', profitText);
      }
    } catch(err) {
      log('Trade error: ' + (err.reason || err.message || err));
    }
  }

  // decide logic (same as your code)
  function decide(){
    if (!bars.length) return null;
    const lrc = computeLRC_Open(bars, 100, 2, 2);
    const ut  = computeUTBotSignals(bars, Number(elUtAtr.value||1), Number(elUtFactor.value||10));
    const rsi = computeRSI(bars, 14);
    const i = bars.length-1;
    const sigUT = ut.signals[i];
    const price = bars[i].close;
    const lower = lrc.lower[i], upper = lrc.upper[i];
    const curRSI = rsi[i] ?? null;
    if (sigUT === 'buy' && lower!=null && price <= lower && curRSI !== null && curRSI < 30) return 'buy';
    if ((sigUT === 'sell') || (upper!=null && price >= upper && curRSI !== null && curRSI > 70)) return 'sell';
    return null;
  }

  // evaluate and send emails & optionally trade
  async function evaluateAndMaybeTrade(){
    const signal = decide();
    if (!signal) return;
    const price = bars[bars.length-1].close;
    const pair = elSymbol.value || 'CAKEUSDT';

    // send immediate signal email (deduped by bar)
    await sendSignalEmail(signal.toUpperCase(), pair, price, elInterval.value||'5m', 'Signal');

    // if auto mode, execute trade automatically
    if (auto){
      log('AUTO executing signal: '+signal);
      await executeTrade(signal);
    } else {
      log('Signal detected (auto disabled): '+signal);
    }
  }

  // polling / data update
  async function startPolling(){
    if (polling) clearInterval(polling);
    const sym = elSymbol.value || "CAKEUSDT";
    const tf = elInterval.value || "5m";
    try {
      bars = await fetchInitial(sym, tf, Number(elBarsKeep.value||600));
      renderAll();
      await mountTradingViewOnce();
      log(`Loaded ${bars.length} bars for ${sym} ${tf}`);
    } catch(e){ log('Load error: '+(e.message||e)); }

    const ms = tf==="1m"?10000:tf==="5m"?30000:60000;
    polling = setInterval(async ()=>{
      try{
        const latest = await fetchLatest(sym, tf);
        const keep = Number(elBarsKeep.value||600);
        if (bars.length && bars[bars.length-1].t === latest.t) bars[bars.length-1] = latest;
        else bars = [...bars, latest].slice(-keep);
        renderAll();
        // evaluate signals each poll
        await evaluateAndMaybeTrade();
      }catch(e){ log('Poll error: '+(e.message||e)); }
    }, ms);
  }

  // TV mount (same as your code)
  let _tvWidgetInited=false,_tvPrevSymbol=null,_tvPrevInterval=null;
  async function mountTradingViewOnce(){
    const tvSymbol = elSymbol.value || 'CAKEUSDT';
    const tvFull = `BINANCE:${tvSymbol}`;
    const iv = elInterval.value||'5m';
    const ivMap = {'1m':'1','5m':'5','15m':'15','30m':'30','1h':'60'};
    const tvInterval = ivMap[iv]||iv;
    if (_tvWidgetInited && _tvPrevSymbol===tvFull && _tvPrevInterval===tvInterval) return;
    _tvPrevSymbol=tvFull; _tvPrevInterval=tvInterval;
    const container = document.getElementById('tv_chart');
    container.innerHTML = '';
    let attempts=0;
    while(typeof window.TradingView==='undefined' && attempts<6){ await new Promise(r=>setTimeout(r,300)); attempts++; }
    if(typeof window.TradingView==='undefined'){ log('TradingView unavailable'); container.innerHTML='<div style="padding:12px;color:#a00">TradingView tidak tersedia</div>'; return; }
    try {
      new TradingView.widget({ autosize:true, symbol:tvFull, interval:tvInterval, timezone:"Etc/UTC", theme:"light", style:"1", locale:"id", container_id:"tv_chart" });
      _tvWidgetInited=true;
      log('TradingView mounted: '+tvFull+' @'+tvInterval);
    } catch(e){ log('TV init err: '+(e.message||e)); container.innerHTML='<div style="padding:12px;color:#a00">Gagal memuat TradingView</div>'; }
  }

  // wallet detection & connect (works with MetaMask & Trust)
  async function detectWalletProvider(){
    const any = window.ethereum;
    if (!any) return null;
    if (any.providers && Array.isArray(any.providers)){
      const trust = any.providers.find(p=>p.isTrust || p.isTrustWallet);
      if (trust) return new BrowserProvider(trust);
      const mm = any.providers.find(p=>p.isMetaMask);
      if (mm) return new BrowserProvider(mm);
      return new BrowserProvider(any.providers[0]);
    }
    return new BrowserProvider(any);
  }
  async function connectWallet(){
    walletProvider = await detectWalletProvider();
    if (!walletProvider) { alert('Wallet EIP-1193 tidak ditemukan'); return false; }
    try {
      await walletProvider.send('eth_requestAccounts', []);
      signer = await walletProvider.getSigner();
      address = await signer.getAddress();
      elAddr.textContent = address.slice(0,6)+'…'+address.slice(-4);
      log('Wallet connected: '+address);
      return true;
    } catch(e){ log('Connect failed: '+(e.message||e)); return false; }
  }

  // UI wiring
  btnConnect.onclick = async ()=> await connectWallet();
  btnAuto.onclick = async ()=>{
    auto = !auto;
    btnAuto.textContent = auto? 'Stop Auto' : 'Start Auto';
    log('Auto: '+(auto?'ON':'OFF'));
    if (auto) await evaluateAndMaybeTrade();
  };
  btnBuy.onclick = async ()=>{ log('Manual BUY pressed'); await executeTrade('buy', {force:true}); };
  btnSell.onclick = async ()=>{ log('Manual SELL pressed'); await executeTrade('sell', {force:true}); };

  elSymbol.onchange = startPolling;
  elInterval.onchange = startPolling;

  // start UI
  createChart();
  startPolling();

  // small self-tests
  (function runTests(){
    log('AutoBot final script loaded. EmailJS service/template/user public key set as provided.');
  })();

})();
</script>
</body>
</html>
