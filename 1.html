<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UT-Bot Live (Binance) — Candles + EmailJS Alerts</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#07121a;--card:#0b1b26;--accent:#06b6d4;--muted:#8fa6bb}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6f6ff}
  header{padding:12px 16px;background:linear-gradient(90deg,#061226,#071829);display:flex;align-items:center;justify-content:space-between}
  header h1{margin:0;font-size:16px}
  main{display:grid;grid-template-columns:1fr 360px;gap:12px;padding:12px}
  .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
  .controls label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  input,select,button{font-size:14px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071927;color:#eaf8ff;width:100%}
  button{background:var(--accent);color:#052a2f;border:none;cursor:pointer}
  .row{display:flex;gap:8px}
  .small{font-size:13px;color:var(--muted)}
  #chart{height:640px;border-radius:8px;overflow:hidden}
  .log{height:220px;overflow:auto;background:#05121a;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
  .marker-buy{color:#0b8f3b;font-weight:700}
  .marker-sell{color:#e85b4b;font-weight:700}
  footer{padding:10px;color:var(--muted);text-align:center}
  @media(max-width:980px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <h1>UT-Bot Live — Binance + EmailJS Alerts</h1>
  <div class="small">1 UT-Bot alert | 10 timeframe | up to 100k candles</div>
</header>

<main>
  <section class="card">
    <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px">
      <div><strong>Chart Candles (Lightweight)</strong></div>
      <div class="small">Markers BUY/SELL akan muncul & alert dikirim via EmailJS</div>
    </div>
    <div id="chart"></div>
  </section>

  <aside class="card controls">
    <label>Symbol (Binance)</label>
    <input id="symbol" placeholder="ex: CAKEUSDT" value="CAKEUSDT" />

    <label>Timeframe</label>
    <select id="timeframe">
      <option value="1m">1m</option>
      <option value="3m">3m</option>
      <option value="5m">5m</option>
      <option value="15m">15m</option>
      <option value="30m">30m</option>
      <option value="1h">1h</option>
      <option value="2h">2h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
      <option value="1w">1w</option>
    </select>

    <label>Max candles to fetch (max 100000)</label>
    <input id="maxCandles" type="number" min="100" max="100000" value="1000" />

    <label>UT-Bot ATR length</label>
    <input id="atrLen" type="number" min="2" max="100" value="14" />

    <label>UT-Bot Multiplier</label>
    <input id="multiplier" type="number" step="0.1" min="0.5" max="10" value="3" />

    <label>EmailJS: user_id</label>
    <input id="emailjs_user" placeholder="user_xxx" />

    <label>EmailJS: service_id</label>
    <input id="emailjs_service" placeholder="service_xxx" />

    <label>EmailJS: template_id</label>
    <input id="emailjs_template" placeholder="template_xxx" />

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="btnStart">Start</button>
      <button id="btnStop" style="background:#2a3946">Stop</button>
    </div>

    <div style="margin-top:10px">
      <strong>Status</strong>
      <div id="status" class="small">Idle</div>
    </div>

    <div style="margin-top:10px">
      <strong>Logs</strong>
      <div id="log" class="log"></div>
    </div>
    <div style="margin-top:10px" class="small">Note: jika ingin kirim email, isi EmailJS details dan publish template. EmailJS public key (user id) diperlukan.</div>
  </aside>
</main>

<footer class="small card">
  Built-in UT-Bot logic (ATR trailing flip). This is client-only demo. For production autotrade use backend & testnet first.
</footer>

<!-- libs -->
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/emailjs-com@3.2.0/dist/email.min.js"></script>

<script>
(async function(){
  // DOM
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  const statusEl = $('status');

  function log(msg, obj){
    const t = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = `[${t}] ${msg}` + (obj ? ' ' + JSON.stringify(obj) : '');
    logEl.prepend(line);
    // keep only 200 lines
    if (logEl.childNodes.length > 400) logEl.removeChild(logEl.lastChild);
  }

  // Chart setup
  const chartDiv = $('chart');
  const chart = LightweightCharts.createChart(chartDiv, {
    width: chartDiv.clientWidth,
    height: 640,
    layout: { backgroundColor: '#07121a', textColor: '#e6f6ff'},
    grid: { vertLines: {visible:false}, horzLines: {color: 'rgba(255,255,255,0.02)'} },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: 'rgba(255,255,255,0.06)' },
    timeScale: { borderColor: 'rgba(255,255,255,0.06)' }
  });
  window.addEventListener('resize', ()=> chart.applyOptions({ width: chartDiv.clientWidth }));

  const candleSeries = chart.addCandlestickSeries({
    upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350'
  });

  // markers series via setMarkers on candleSeries
  let markers = [];

  // UT-Bot implementation (ATR based trailing stop)
  function computeUTBotSignals(ohlcv, atrLen=14, mult=3){
    // ohlcv: array of {time, open, high, low, close}
    // return signals array same length: 'BUY' | 'SELL' | null
    const n = ohlcv.length;
    if(n < atrLen+2) return Array(n).fill(null);

    // compute TR then ATR simple moving average
    const tr = new Array(n).fill(0);
    for(let i=1;i<n;i++){
      const high = ohlcv[i].high, low = ohlcv[i].low, prevClose = ohlcv[i-1].close;
      tr[i] = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
    }
    const atr = new Array(n).fill(null);
    // SMA ATR
    let sum = 0;
    for(let i=1;i<=atrLen;i++) sum += tr[i];
    atr[atrLen] = sum / atrLen;
    for(let i=atrLen+1;i<n;i++){
      // Wilder ATR smoothing could be used; we'll use EMA-like update
      atr[i] = ( (atr[i-1] * (atrLen - 1)) + tr[i] ) / atrLen;
    }

    const upperBand = new Array(n).fill(null);
    const lowerBand = new Array(n).fill(null);
    const trend = new Array(n).fill(1); // 1 = up, -1 = down
    const signals = new Array(n).fill(null);

    for(let i=atrLen;i<n;i++){
      const hl2 = (ohlcv[i].high + ohlcv[i].low) / 2;
      upperBand[i] = hl2 + mult * atr[i];
      lowerBand[i] = hl2 - mult * atr[i];
    }

    // initial trend: based on close vs upper/lower at first computable point
    let curTrend = 1;
    for(let i=atrLen+1;i<n;i++){
      // flip logic: if close crosses above upperBand => up; if below lowerBand => down
      const c = ohlcv[i].close;
      if(c > upperBand[i-1]) curTrend = 1;
      else if(c < lowerBand[i-1]) curTrend = -1;
      trend[i] = curTrend;

      // adjust bands when trend flips? Using UT bot style trailing stops:
      // When trend is up, we use max(lowerBand over trend) as trailing stop? Simpler: when trend up and close < lowerBand => flip
      if(trend[i] !== trend[i-1]){
        // signal occurs on flip
        signals[i] = (trend[i] === 1) ? 'BUY' : 'SELL';
      }
    }

    return signals;
  }

  // fetch OHLCV from Binance (paginated up to maxCandles)
  // Binance endpoint: /api/v3/klines?symbol=CAKEUSDT&interval=1m&limit=1000&startTime=...&endTime=...
  async function fetchKlines(symbol, interval, maxCandles=1000){
    symbol = symbol.toUpperCase();
    const maxPerReq = 1000;
    let candles = [];
    // fetch most recent first by requesting without startTime -> returns latest limit
    // To collect up to maxCandles we will page backwards using endTime
    let fetchCnt = 0;
    let endTime = undefined;
    while(candles.length < maxCandles){
      const limit = Math.min(maxPerReq, maxCandles - candles.length);
      let url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
      if(endTime) url += `&endTime=${endTime}`;
      log(`Requesting klines: limit=${limit}, endTime=${endTime||'latest'}`);
      const resp = await fetch(url);
      if(resp.status === 429){
        throw new Error('Rate limited by Binance (429). Reduce maxCandles or add delays.');
      }
      if(!resp.ok){
        const txt = await resp.text();
        throw new Error('Klines fetch failed: ' + resp.status + ' ' + txt);
      }
      const data = await resp.json();
      if(!Array.isArray(data) || data.length === 0) break;
      // Binance returns array in ascending time order (oldest->newest) for requested range
      // but when endTime used it returns up to that time. We'll prepend to candles and then set new endTime to first item's openTime - 1
      // To avoid duplicates, if endTime undefined and data.length < limit we still take them.
      // We'll insert at front to accumulate older first then later sort.
      candles = data.concat(candles);
      // set next endTime to first item's open time - 1ms
      const firstOpen = data[0][0];
      endTime = firstOpen - 1;
      fetchCnt++;
      // small delay to be polite to API
      await new Promise(r => setTimeout(r, 200)); // 200ms
      // safety break
      if(fetchCnt > 200) break;
    }

    // Map to objects and sort ascending by time
    const mapped = candles.map(c => ({
      time: Math.floor(c[0] / 1000), // seconds
      open: Number(c[1]), high: Number(c[2]), low: Number(c[3]), close: Number(c[4]), volume: Number(c[5])
    }));
    // keep last maxCandles entries (in case we over-collected)
    const result = mapped.slice(-maxCandles);
    return result;
  }

  // draw candles & markers
  function drawCandles(ohlcv){
    const data = ohlcv.map(c => ({ time: c.time, open: c.open, high: c.high, low: c.low, close: c.close }));
    candleSeries.setData(data);
  }

  function drawMarkers(ohlcv, signals){
    markers = [];
    for(let i=0;i<ohlcv.length;i++){
      if(signals[i] === 'BUY'){
        markers.push({ time: ohlcv[i].time, position: 'belowBar', color: '#00d28a', shape: 'arrowUp', text: 'BUY' });
      } else if(signals[i] === 'SELL'){
        markers.push({ time: ohlcv[i].time, position: 'aboveBar', color: '#ff6b6b', shape: 'arrowDown', text: 'SELL' });
      }
    }
    candleSeries.setMarkers(markers);
  }

  // EmailJS helper
  function initEmailJS(userId){
    try{
      if(window.emailjs && typeof window.emailjs.init === 'function'){
        window.emailjs.init(userId);
        return true;
      } else return false;
    }catch(e){ return false; }
  }
  async function sendEmail(serviceId, templateId, templateParams){
    if(!window.emailjs) throw new Error('EmailJS not loaded');
    return window.emailjs.send(serviceId, templateId, templateParams);
  }

  // main flow
  let running = false;
  let lastSentSignalTime = null; // avoid duplicate
  $('btnStart').addEventListener('click', async ()=>{
    if(running) return;
    running = true;
    $('btnStart').disabled = true;
    $('btnStop').disabled = false;
    statusEl.textContent = 'Running';
    log('Starting UT-Bot live fetch');

    const symbol = $('symbol').value.trim().toUpperCase();
    const timeframe = $('timeframe').value;
    const maxCandles = Math.min(100000, Number($('maxCandles').value) || 1000);
    const atrLen = Number($('atrLen').value) || 14;
    const mult = Number($('multiplier').value) || 3;
    const email_user = $('emailjs_user').value.trim();
    const email_service = $('emailjs_service').value.trim();
    const email_template = $('emailjs_template').value.trim();

    if(email_user) {
      try{
        initEmailJS(email_user);
        log('EmailJS initialized (user: ' + email_user + ')');
      }catch(e){
        log('EmailJS init error', e.message || e);
      }
    }

    try{
      // fetch klines up to maxCandles (this might take time)
      log('Fetching klines, symbol=' + symbol + ', tf=' + timeframe + ', max=' + maxCandles);
      const ohlcv = await fetchKlines(symbol, timeframe, maxCandles);
      log('Fetched candles: ' + ohlcv.length);
      drawCandles(ohlcv);

      // compute signals
      const signals = computeUTBotSignals(ohlcv, atrLen, mult);
      drawMarkers(ohlcv, signals);

      // check latest signal
      const lastIdx = signals.length - 1;
      const lastSignal = signals[lastIdx];
      if(lastSignal){
        const lastTime = ohlcv[lastIdx].time;
        // dedupe: don't send same signal for same candle more than once
        if(lastSentSignalTime !== lastTime || lastSentSignalTime === null){
          lastSentSignalTime = lastTime;
          log('Signal detected: ' + lastSignal + ' at ' + new Date(lastTime * 1000).toISOString());
          // send email if configured
          if(email_user && email_service && email_template){
            try{
              const params = {
                symbol, timeframe, signal: lastSignal, time: new Date(lastTime * 1000).toISOString(),
                price: ohlcv[lastIdx].close
              };
              log('Sending email via EmailJS', params);
              await sendEmail(email_service, email_template, params);
              log('Email sent');
            }catch(e){
              log('Email send failed', e.message || e);
            }
          }else{
            log('EmailJS config missing; not sending email');
          }
        } else {
          log('Signal same as last sent signal (deduped)');
        }
      } else log('No signal in latest candle');

    }catch(err){
      log('Error in run: ' + (err.message || err));
      statusEl.textContent = 'Error: ' + (err.message || err);
    } finally {
      running = false;
      $('btnStart').disabled = false;
      $('btnStop').disabled = true;
      statusEl.textContent = 'Idle';
    }
  });

  $('btnStop').addEventListener('click', ()=>{
    running = false;
    $('btnStart').disabled = false;
    $('btnStop').disabled = true;
    statusEl.textContent = 'Stopped';
    log('Stopped by user');
  });

  // init defaults
  $('btnStop').disabled = true;

  // load EmailJS lib init (global variable emailjs)
  // emailjs init is called when starting if user filled user id
  // but we load SDK script above; ensure it's available
  if(window.emailjs) {
    log('EmailJS SDK loaded');
  } else {
    log('EmailJS SDK not loaded (network?)');
  }

})();
</script>
</body>
</html>
