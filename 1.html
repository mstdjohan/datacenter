<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UT Bot (2,10) + LRC (100,2,2) • CAKE/USDT • Auto-Signal & Swap</title>

<!-- Ethers.js -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<!-- WalletConnect v2 UMD -->
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.11.1/dist/index.umd.min.js"></script>
<!-- EmailJS -->
<script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>

<style>
:root{--bg:#06121a;--panel:#071826;--muted:#99b6c6;--text:#e6f7ff;--accent:#38bdf8;--ok:#22c55e;--bad:#ff6b6b}
*{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
.header{display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid #0f3340;background:var(--panel)}
.container{display:grid;grid-template-columns:360px 1fr;gap:12px;padding:12px}
.card{background:linear-gradient(180deg,#071726,#06121a);border:1px solid #0e2b36;border-radius:12px;padding:12px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
label{font-size:12px;color:var(--muted)}
input,select,button{background:#05101a;color:var(--text);border:1px solid #083243;border-radius:10px;padding:8px 10px;font-size:13px}
button.primary{background:var(--accent);color:#001018;border:none}
.badge{padding:4px 8px;border-radius:999px;background:#042028;border:1px solid #083243;color:#9fc5d8;font-size:12px}
#log{height:360px;overflow:auto;font-family:ui-monospace,Menlo,monospace;background:#021018;border-radius:10px;padding:10px}
small{color:var(--muted)}
@media(max-width:980px){.container{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="header">
  <div><strong>UT Bot (2,10) + LRC (100,2,2)</strong> • CAKE/USDT Auto-Signal & Swap</div>
  <div class="row">
    <span id="status" class="badge">Idle</span>
    <button id="btnToggle" class="primary">Start</button>
  </div>
</div>

<div class="container">
  <aside class="card">
    <h4 style="margin:0 0 8px">Konfigurasi & Koneksi</h4>

    <div class="row" style="margin-bottom:8px">
      <label style="min-width:110px">Symbol</label>
      <input id="symbol" value="CAKEUSDT" style="width:140px">
      <label>TF</label>
      <select id="interval"><option>1m</option><option>3m</option><option selected>5m</option><option>15m</option><option>1h</option></select>
    </div>

    <div style="margin-top:6px" class="row">
      <label style="min-width:110px">Candles</label>
      <input id="limit" type="number" value="500" style="width:100px">
      <label style="min-width:110px;margin-left:8px">KV</label>
      <input id="kv" type="number" value="2" step="0.1" style="width:80px">
      <label style="min-width:60px">ATR</label>
      <input id="atr" type="number" value="10" style="width:80px">
    </div>

    <div style="margin-top:10px" class="row">
      <label style="min-width:110px">LRC len</label>
      <input id="lrLen" type="number" value="100" style="width:90px">
      <label>devUp</label><input id="devUp" type="number" value="2" step="0.1" style="width:70px">
      <label>devDn</label><input id="devDn" type="number" value="2" step="0.1" style="width:70px">
    </div>

    <hr style="border:none;border-top:1px solid #083243;margin:10px 0">

    <h4 style="margin:6px 0">EmailJS (opsional)</h4>
    <div class="row" style="margin-bottom:6px"><input id="emailService" placeholder="service_xxx" style="flex:1"></div>
    <div class="row" style="margin-bottom:6px"><input id="emailTemplate" placeholder="template_xxx" style="flex:1"><input id="emailUser" placeholder="public_xxx" style="flex:1"></div>
    <div class="row" style="margin-bottom:6px"><input id="emailTo" placeholder="tujuan@domain.com" style="flex:1"><button id="btnInitEmail">Init EmailJS</button></div>
    <div id="emailBadge" class="badge">EmailJS: Not set</div>

    <hr style="border:none;border-top:1px solid #083243;margin:10px 0">

    <h4 style="margin:6px 0">Wallet (opsional, untuk swap)</h4>
    <div class="row" style="margin-bottom:8px">
      <input id="wcProjectId" placeholder="WalletConnect Project ID (Trust Wallet)" style="flex:1">
      <button id="btnConnect">Connect Wallet</button>
    </div>
    <div class="row" style="margin-bottom:8px">
      <div>Account: <span id="acct" class="badge">-</span></div>
    </div>

    <hr style="border:none;border-top:1px solid #083243;margin:10px 0">

    <h4 style="margin:6px 0">Manual Swap</h4>
    <div class="row" style="margin-bottom:8px">
      <select id="side"><option value="USDT2CAKE">BUY CAKE (USDT→CAKE)</option><option value="CAKE2USDT">SELL CAKE (CAKE→USDT)</option></select>
      <input id="amount" type="number" step="0.000001" placeholder="amount" style="width:120px">
    </div>
    <div class="row" style="margin-bottom:8px">
      <input id="slip" type="number" value="0.6" style="width:90px"><label>% slippage</label>
      <input id="deadline" type="number" value="10" style="width:90px"><label>min deadline</label>
      <button id="btnQuote">Quote</button>
      <button id="btnSwap" class="primary">Swap Now</button>
    </div>

    <small>Pastikan test kecil dulu. Halaman ini tidak menyimpan private key — wallet menandatangani transaksi.</small>
  </aside>

  <main class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div><b>Live:</b> <span id="live">-</span></div>
        <div style="margin-top:6px"><b>Signal:</b> <span id="signal" class="badge">-</span></div>
      </div>
      <div>
        <div><b>UT Trend:</b> <span id="trend" class="badge">-</span></div>
        <div style="margin-top:6px"><b>Last bar:</b> <span id="lastBar" class="badge">-</span></div>
      </div>
    </div>

    <div id="log" style="margin-top:12px"></div>
  </main>
</div>

<script>
/* ==== Constants (BSC mainnet tokens & router) ==== */
const CAKE = "0x0E09Fabb73Bd3Ade0a17ECC321fD13a19e81cE82";
const USDT = "0x55d398326f99059fF775485246999027B3197955";
const ROUTER = "0x10ED43C718714eb63d5aA57B78B54704E256024E"; // Pancake v2 router
const BSC_RPC = "https://bsc-dataseed.binance.org/";

/* ==== ABIs (minimal) ==== */
const ERC20_ABI = [
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint)",
  "function allowance(address owner,address spender) view returns (uint)",
  "function approve(address spender, uint value) returns (bool)"
];
const ROUTER_ABI = [
  "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)",
  "function swapExactTokensForTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external returns (uint[] memory amounts)"
];

/* ==== State ==== */
const state = {
  running:false,
  lastAlertBar:null,
  email:{service:"",template:"",user:"",to:""},
  wallet:{provider:null,ethers:null,signer:null,account:null,wcProvider:null}
};

/* ==== UI helpers ==== */
const $ = id => document.getElementById(id);
function log(msg){ $("log").innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}<br>` + $("log").innerHTML; }
function setStatus(v){ $("status").textContent = v; }

/* ==== EmailJS init/save ==== */
$("btnInitEmail").onclick = ()=>{
  state.email.service = $("emailService").value.trim();
  state.email.template = $("emailTemplate").value.trim();
  state.email.user = $("emailUser").value.trim();
  state.email.to = $("emailTo").value.trim();
  try{
    if(!window.emailjs) throw new Error("EmailJS SDK belum termuat");
    if(state.email.user) emailjs.init(state.email.user);
    localStorage.setItem("email_cfg", JSON.stringify(state.email));
    $("emailBadge").textContent = "EmailJS: Ready";
    log("EmailJS dikonfigurasi");
  }catch(e){ log("EmailJS init error: "+(e.message||e)); $("emailBadge").textContent = "EmailJS: Error"; }
};
(function(){ try{ const c = JSON.parse(localStorage.getItem("email_cfg")||"{}"); if(c){ Object.assign(state.email,c); $("emailService").value=c.service||""; $("emailTemplate").value=c.template||""; $("emailUser").value=c.user||""; $("emailTo").value=c.to||""; if(c.user && window.emailjs) emailjs.init(c.user); $("emailBadge").textContent = c.user? "EmailJS: Ready":"EmailJS: Not set"; } }catch(_){} })();

/* ==== Wallet connect (MetaMask or WalletConnect v2) ==== */
$("btnConnect").onclick = async ()=>{
  try{
    // MetaMask preferred
    if(window.ethereum && window.ethereum.isMetaMask){
      state.wallet.provider = window.ethereum;
      state.wallet.ethers = new ethers.providers.Web3Provider(window.ethereum);
      await state.wallet.ethers.send("eth_requestAccounts", []);
      state.wallet.signer = state.wallet.ethers.getSigner();
      state.wallet.account = await state.wallet.signer.getAddress();
      $("acct").textContent = state.wallet.account;
      setStatus("Wallet: Connected (MetaMask)");
      log("Connected MetaMask: "+state.wallet.account);
    } else {
      const pid = $("wcProjectId").value.trim() || localStorage.getItem("wc_project_id");
      if(!pid){ alert("Masukkan WalletConnect Project ID untuk Trust Wallet"); return; }
      localStorage.setItem("wc_project_id", pid);
      const WC = window.WalletConnectEthereumProvider;
      if(!WC) throw new Error("WalletConnect SDK belum termuat");
      state.wallet.wcProvider = await WC.init({ projectId: pid, chains: [56], showQrModal: true });
      await state.wallet.wcProvider.enable();
      state.wallet.ethers = new ethers.providers.Web3Provider(state.wallet.wcProvider);
      state.wallet.signer = state.wallet.ethers.getSigner();
      state.wallet.account = await state.wallet.signer.getAddress();
      $("acct").textContent = state.wallet.account;
      setStatus("Wallet: Connected (WalletConnect)");
      log("Connected WalletConnect: "+state.wallet.account);
    }
  }catch(e){ log("Gagal connect wallet: "+(e.message||e)); setStatus("Wallet: Disconnected"); }
};

/* ==== Binance Klines (no API key) ==== */
const tfToBinance = {'1m':'1m','3m':'3m','5m':'5m','15m':'15m','1h':'1h'};
async function getKlines(symbol, interval, limit){
  const tf = tfToBinance[interval] || '5m';
  const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${tf}&limit=${limit}`;
  const res = await fetch(url, { cache:'no-store' });
  if(!res.ok) throw new Error("Binance HTTP " + res.status);
  const arr = await res.json();
  // [openTime, open, high, low, close, vol, closeTime,...]
  return arr.map(k => ({ time: Math.floor(k[6]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5] }));
}
async function getLastPrice(symbol){
  try{
    const r = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`, {cache:'no-store'});
    if(!r.ok) return null;
    const j = await r.json(); return +j.price;
  }catch(e){ return null; }
}

/* ==== Indicators: trueRange, ATR, UT Bot, Linear Regression Channel ==== */
function trueRange(c){ const t=[NaN]; for(let i=1;i<c.length;i++){ const a=c[i], b=c[i-1]; t.push(Math.max(a.high-a.low, Math.abs(a.high-b.close), Math.abs(a.low-b.close))); } return t; }
function atr(c,p=10){ const t=trueRange(c); const o=new Array(c.length).fill(NaN); let s=0, i=1; while(i<=p && i<t.length){ s+=t[i]; i++; } if(i<=p) return o; o[p]=s/p; for(let j=p+1;j<t.length;j++){ o[j]=(o[j-1]*(p-1)+t[j])/p } return o; }

/* UT Bot (version adapted) */
function utBot(c, kv=2, aP=10){
  const n=c.length;
  const A = atr(c,aP);
  const trend = new Array(n).fill(0);
  const upper = new Array(n).fill(NaN);
  const lower = new Array(n).fill(NaN);
  for(let i=0;i<n;i++){
    const x=c[i];
    const hl2 = (x.high + x.low)/2;
    const nLoss = kv * (A[i] || NaN);
    if(!isFinite(nLoss)){ trend[i] = i?trend[i-1]:0; continue; }
    const bU = hl2 + nLoss, bL = hl2 - nLoss;
    if(i===0){ upper[i]=bU; lower[i]=bL; }
    else {
      const pU = upper[i-1], pL = lower[i-1];
      upper[i] = (bU < pU || x.close > pU) ? bU : pU;
      lower[i] = (bL > pL || x.close < pL) ? bL : pL;
    }
    const prev = i?trend[i-1]:0;
    trend[i] = x.close > upper[i] ? 1 : x.close < lower[i] ? -1 : prev;
  }
  return { trend, upper, lower };
}

/* Linear Regression Channel */
function linRegChannel(c, len=100, devUp=2, devDn=2){
  const n = c.length;
  const mid = new Array(n).fill(NaN), up = new Array(n).fill(NaN), dn = new Array(n).fill(NaN);
  for(let i=len-1;i<n;i++){
    const slice = c.slice(i-len+1, i+1);
    const y = slice.map(z=>z.close);
    const M = y.length;
    const X = [...Array(M).keys()];
    const SX = X.reduce((a,b)=>a+b,0);
    const SY = y.reduce((a,b)=>a+b,0);
    const SXX = X.reduce((a,b)=>a+b*b,0);
    const SXY = X.reduce((a,b,j)=>a + b*y[j],0);
    const D = M*SXX - SX*SX;
    const slope = D !== 0 ? (M*SXY - SX*SY)/D : 0;
    const intercept = (SY - slope*SX)/M;
    const yHat = intercept + slope*(M-1);
    const s2 = y.reduce((a,v,j)=>{ const est = intercept + slope*j; return a + (v - est)*(v - est); },0)/M;
    const sd = Math.sqrt(s2);
    mid[i] = yHat; up[i]= yHat + devUp*sd; dn[i]= yHat - devDn*sd;
  }
  return { mid, up, dn };
}

/* ==== Core step: fetch candles, compute indicators, detect cross ==== */
async function step(){
  try{
    const symbol = $("symbol").value.trim().toUpperCase();
    const interval = $("interval").value;
    const limit = Math.max(120, (+$("limit").value || 500));
    const kv = +$("kv").value; const aP = +$("atr").value;
    const lrLen = +$("lrLen").value; const devUp = +$("devUp").value; const devDn = +$("devDn").value;

    const [candles, lastPx] = await Promise.all([ getKlines(symbol, interval, limit), getLastPrice(symbol) ]);
    if(lastPx) $("live").textContent = lastPx.toFixed(6);

    if(!candles.length) { log("No candles"); return; }
    const ut = utBot(candles, kv, aP);
    const lr = linRegChannel(candles, lrLen, devUp, devDn);

    const last = candles.at(-1);
    const prevTrend = ut.trend.at(-2) ?? 0;
    const nowTrend = ut.trend.at(-1) ?? 0;

    $("trend").textContent = nowTrend>0 ? "UP" : nowTrend<0 ? "DOWN" : "-";
    $("lastBar").textContent = new Date(last.time*1000).toLocaleString();
    $("signal").textContent = nowTrend>0 ? "BUY" : nowTrend<0 ? "SELL" : "-";
    $("signal").className = "badge " + (nowTrend>0 ? "ok" : nowTrend<0 ? "bad" : "");

    // detect cross (previous different + now different) and once per bar key
    const barKey = last.time;
    if(state.lastAlertBar !== barKey && prevTrend !== nowTrend && nowTrend !== 0){
      const side = nowTrend>0 ? "BUY" : "SELL";
      log(`Signal detected: ${side} ${symbol} ~${(lastPx||last.close).toFixed(6)}`);
      // send email if configured
      sendEmail(side, symbol, (lastPx||last.close), new Date(last.time*1000).toLocaleString());
      // set lastAlertBar so we don't duplicate in same bar
      state.lastAlertBar = barKey;
      // Auto-prompt user to swap (optional): ask confirm
      if(state.wallet.signer){
        // Ask user if want to auto-execute
        setTimeout(()=> {
          const exec = confirm(`Signal ${side} detected. Execute swap now? (OK untuk execute)`);
          if(exec){
            // default: user enters amount in manual field before approval
            const amt = parseFloat($("amount").value || "0");
            if(!(amt>0)){ alert("Masukkan jumlah di field Amount sebelum konfirmasi auto-swap."); return; }
            // set side accordingly
            if(side==="BUY") $("side").value = "USDT2CAKE"; else $("side").value = "CAKE2USDT";
            doSwap();
          }
        }, 500);
      }
    }
  }catch(err){
    log("Step error: " + (err.message || err));
  }
}

/* ==== Email sender ==== */
async function sendEmail(side, symbol, price, time){
  try{
    if(!(state.email && state.email.service && state.email.template && state.email.user)) return;
    await emailjs.send(state.email.service, state.email.template, {
      signal: side,
      symbol,
      price: String(price),
      time,
      to: state.email.to || ""
    });
    log("Email sent: "+side);
  }catch(e){ log("Email send failed: "+(e.text||e.message||e)); }
}

/* ==== Start/Stop ==== */
$("btnToggle").onclick = ()=>{
  state.running = !state.running;
  $("btnToggle").textContent = state.running ? "Stop" : "Start";
  setStatus(state.running ? "Running" : "Idle");
  if(state.running){ step(); state._timer = setInterval(step, 30000); } else { clearInterval(state._timer); state._timer = null; }
};

/* ==== Swap functions: quote, approve, swap ==== */
async function getQuote(side, amountFloat){
  try{
    const provider = new ethers.providers.JsonRpcProvider(BSC_RPC);
    const router = new ethers.Contract(ROUTER, ROUTER_ABI, provider);
    const cake = new ethers.Contract(CAKE, ERC20_ABI, provider);
    const usdt = new ethers.Contract(USDT, ERC20_ABI, provider);
    const dCake = await cake.decimals();
    const dUsdt = await usdt.decimals();
    if(side === "CAKE2USDT"){
      const amtIn = ethers.utils.parseUnits(String(amountFloat), dCake);
      const amounts = await router.getAmountsOut(amtIn, [CAKE, USDT]);
      return { outBN: amounts[1], outDecimals: dUsdt };
    } else {
      const amtIn = ethers.utils.parseUnits(String(amountFloat), dUsdt);
      const amounts = await router.getAmountsOut(amtIn, [USDT, CAKE]);
      return { outBN: amounts[1], outDecimals: dCake };
    }
  }catch(e){ throw e; }
}
$("btnQuote").onclick = async ()=>{
  try{
    const side = $("side").value;
    const amt = +$("amount").value;
    if(!(amt>0)){ alert("Masukkan jumlah > 0"); return; }
    const q = await getQuote(side, amt);
    const human = ethers.utils.formatUnits(q.outBN, q.outDecimals);
    log(`Quote: ${side} ${amt} → est ${human}`);
    alert(`Quote approx: ${human}`);
  }catch(e){ log("Quote error: "+(e.message||e)); alert("Quote error: "+(e.message||e)); }
};

async function ensureAllowance(tokenAddr, signer, spender, amountBN){
  const token = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
  const owner = await signer.getAddress();
  const current = await token.allowance(owner, spender);
  if(current.gte(amountBN)) return true;
  const tx = await token.approve(spender, amountBN);
  log("Approve tx sent: " + tx.hash);
  await tx.wait();
  log("Approve done");
  return true;
}

async function doSwap(){
  try{
    if(!state.wallet.signer){ alert("Connect wallet first"); return; }
    const side = $("side").value;
    const amt = +$("amount").value;
    const slipPct = +$("slip").value/100;
    const deadlineMin = +$("deadline").value || 10;
    if(!(amt>0)){ alert("Enter valid amount"); return; }

    const signer = state.wallet.signer;
    const provider = state.wallet.ethers || new ethers.providers.JsonRpcProvider(BSC_RPC);
    // Read decimals
    const cakeRead = new ethers.Contract(CAKE, ERC20_ABI, provider);
    const usdtRead = new ethers.Contract(USDT, ERC20_ABI, provider);
    const dCake = await cakeRead.decimals();
    const dUsdt = await usdtRead.decimals();

    let amountInBN, path;
    if(side === "CAKE2USDT"){
      amountInBN = ethers.utils.parseUnits(String(amt), dCake);
      path = [CAKE, USDT];
      await ensureAllowance(CAKE, signer, ROUTER, amountInBN);
    } else {
      amountInBN = ethers.utils.parseUnits(String(amt), dUsdt);
      path = [USDT, CAKE];
      await ensureAllowance(USDT, signer, ROUTER, amountInBN);
    }

    // Compute minOut with getAmountsOut
    const routerRead = new ethers.Contract(ROUTER, ROUTER_ABI, provider);
    const amounts = await routerRead.getAmountsOut(amountInBN, path);
    const outBN = amounts[amounts.length-1];
    const minOut = outBN.sub(outBN.mul(ethers.BigNumber.from(Math.floor(slipPct*1e6))).div(ethers.BigNumber.from(1e6)));

    const deadline = Math.floor(Date.now()/1000) + deadlineMin*60;
    log(`Sending swap: ${side} amountIn=${amt} minOut≈${ethers.utils.formatUnits(minOut, side==="CAKE2USDT"?dUsdt:dCake)}`);

    const router = new ethers.Contract(ROUTER, ROUTER_ABI, signer);
    const tx = await router.swapExactTokensForTokens(amountInBN, minOut, path, await signer.getAddress(), deadline, { gasLimit: 800000 });
    log("Swap tx sent: " + tx.hash);
    const receipt = await tx.wait();
    log("Swap success. Block: " + receipt.blockNumber);

    // after swap, notify via email if configured
    if(state.email && state.email.service && state.email.template && state.email.user){
      try{
        await emailjs.send(state.email.service, state.email.template, {
          signal: side === "USDT2CAKE" ? "BUY" : "SELL",
          symbol: "CAKE/USDT",
          price: $("live").textContent || "-",
          txhash: tx.hash,
          time: new Date().toLocaleString(),
          to: state.email.to || ""
        });
        log("EmailJS: notification sent");
      }catch(e){ log("EmailJS error: "+(e.text||e.message||e)); }
    }

  }catch(e){ log("Swap error: "+(e.message||e)); alert("Swap failed: "+(e.message||e)); }
}
$("btnSwap").onclick = doSwap;

/* ==== small utility: formatting ==== */
function fmt(n, d=6){ return (typeof n==='number' && isFinite(n)) ? n.toFixed(d) : '-' }

/* ==== Auto-loop start indicator default ==== */
setStatus("Idle");
log("Ready — isi config EmailJS (opsional), connect wallet (opsional), lalu tekan Start untuk loop indikator.");

/* ==== Safety note repeated ==== */
log("⚠️ TEST with small amounts first. This script executes real swaps on BSC Mainnet when you confirm.");

</script>
</body>
</html>
