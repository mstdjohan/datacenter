<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>UT-Bot Chart — Fixed (Binance live, LRC, markers)</title>

<!-- Lightweight Charts (standalone build) -->
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

<style>
  :root{
    --bg:#071018; --panel:#0b1620; --text:#e6eef7; --muted:#9fb4c9;
    --up:#26a69a; --down:#ef5350; --lrc:'#60A5FA';
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Arial}
  .wrap{max-width:1100px;margin:12px auto;padding:10px;box-sizing:border-box}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
  select,input,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071927;color:var(--text)}
  button{cursor:pointer}
  button.primary{background:#06b6d4;border:0;color:#032b30;font-weight:700}
  #chartHolder{width:100%;height:560px;border-radius:8px;background:#07121a;margin-top:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .row{display:flex;gap:8px;align-items:center}
  .log{margin-top:10px;background:#05121a;padding:8px;border-radius:8px;height:140px;overflow:auto;font-family:monospace;font-size:13px}
  .small{color:var(--muted);font-size:13px}
  @media(max-width:720px){ #chartHolder{height:420px} .controls{gap:6px} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>UT-Bot Live (fixed) — Binance klines, LRC, BUY/SELL markers</h1>
        <div class="small">Pastikan buka via http/https server (jangan file://). Jika blank, cek console (remote debug).</div>
      </div>
      <div class="small">Lightweight Charts demo</div>
    </header>

    <div class="controls" style="margin-top:12px">
      <label class="small">Symbol</label>
      <input id="symbol" value="CAKEUSDT" style="width:140px" />

      <label class="small">Interval</label>
      <select id="interval">
        <option value="1m">1m</option><option value="3m">3m</option><option value="5m">5m</option>
        <option value="15m">15m</option><option value="30m">30m</option><option value="1h">1h</option>
        <option value="4h">4h</option><option value="1d">1d</option>
      </select>

      <label class="small">Candles</label>
      <input id="limit" type="number" value="500" min="50" max="1000" style="width:90px" />

      <button id="btnLoad" class="primary">Load Chart</button>
      <button id="btnReload" disabled>Reload</button>
      <button id="btnDbg">Open Console</button>
    </div>

    <div id="chartHolder"></div>

    <div style="display:flex;gap:12px;margin-top:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="small">Indicator & strategy settings</div>
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
          <div style="min-width:140px"><label class="small">ATR length</label><input id="atrLen" type="number" value="14" min="2" style="width:100%"/></div>
          <div style="min-width:140px"><label class="small">ATR mult</label><input id="atrMult" type="number" value="3" step="0.1" style="width:100%"/></div>
          <div style="min-width:140px"><label class="small">LRC len</label><input id="lrcLen" type="number" value="100" style="width:100%"/></div>
          <div style="min-width:140px"><label class="small">LRC mult (σ)</label><input id="lrcMult" type="number" value="2" step="0.1" style="width:100%"/></div>
        </div>
      </div>

      <div style="width:360px">
        <div class="small">Status</div>
        <div id="status" class="small" style="margin-top:6px;color:var(--muted)"></div>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

<script>
(async function(){
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  function log(msg, obj){
    const t = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = `[${t}] ${msg}` + (obj ? ' ' + JSON.stringify(obj) : '');
    logEl.prepend(line);
    if(logEl.childNodes.length > 400) logEl.removeChild(logEl.lastChild);
    console.log(msg, obj || '');
  }
  function setStatus(s){ $('status').textContent = s; }

  // --- Chart init & resize handling
  const holder = $('chartHolder');
  let chart = null, candleSeries = null, lrcCenter = null, lrcUp = null, lrcLow = null;
  function createChart(){
    holder.innerHTML = '';
    chart = LightweightCharts.createChart(holder, {
      layout: { backgroundColor: '#07121a', textColor: '#e6eef7' },
      grid: { vertLines: { color: 'rgba(255,255,255,0.02)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
      rightPriceScale: { borderColor: 'rgba(255,255,255,0.06)' },
      timeScale: { borderColor: 'rgba(255,255,255,0.06)' }
    });
    candleSeries = chart.addCandlestickSeries({
      upColor: '#26a69a', downColor: '#ef5350', wickUpColor:'#26a69a', wickDownColor:'#ef5350', borderVisible:false
    });
    lrcCenter = chart.addLineSeries({ color:'#60A5FA', lineWidth:2 });
    lrcUp = chart.addLineSeries({ color:'#7FB3FF', lineWidth:1, lineStyle: LightweightCharts.LineStyle.Dotted });
    lrcLow = chart.addLineSeries({ color:'#7FB3FF', lineWidth:1, lineStyle: LightweightCharts.LineStyle.Dotted });
    window.addEventListener('resize', ()=> chart.applyOptions({ width: holder.clientWidth }));
  }

  // --- Binance klines fetch (single call limit 1000)
  async function fetchKlines(symbol, interval, limit=500){
    symbol = symbol.toUpperCase();
    const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
    log('Fetching klines', {url});
    const r = await fetch(url);
    if(r.status===429) throw new Error('Binance rate limited (429). Reduce limit or add delay.');
    if(!r.ok){
      const txt = await r.text(); throw new Error('Klines fetch failed: ' + r.status + ' ' + txt);
    }
    const j = await r.json();
    // Map to lightweight-charts format (time in seconds)
    return j.map(d => ({ time: Math.floor(d[0]/1000), open: +d[1], high:+d[2], low:+d[3], close:+d[4] }));
  }

  // --- Indicators (ATR + UT-like Supertrend flip) and LRC
  function computeTR(candles){
    const tr = new Array(candles.length).fill(NaN);
    for(let i=1;i<candles.length;i++){
      const prev = candles[i-1].close;
      tr[i] = Math.max(candles[i].high - candles[i].low, Math.abs(candles[i].high - prev), Math.abs(candles[i].low - prev));
    }
    return tr;
  }
  function computeATR(candles, period){
    const tr = computeTR(candles);
    const atr = new Array(candles.length).fill(NaN);
    let sum = 0;
    for(let i=1;i<=period;i++) sum += tr[i] || 0;
    atr[period] = sum/period;
    for(let i=period+1;i<candles.length;i++){
      atr[i] = ((atr[i-1] * (period-1)) + tr[i]) / period;
    }
    return atr;
  }

  function supertrendSignals(candles, atrLen=14, mult=3){
    const n = candles.length;
    const atr = computeATR(candles, atrLen);
    const hl2 = candles.map(c => (c.high + c.low)/2);
    const upper = new Array(n).fill(NaN), lower = new Array(n).fill(NaN), finalUpper = new Array(n).fill(NaN), finalLower = new Array(n).fill(NaN);
    const trend = new Array(n).fill(1);
    const signals = []; // {index, type, time, price}
    for(let i=atrLen;i<n;i++){
      upper[i] = hl2[i] + mult * atr[i];
      lower[i] = hl2[i] - mult * atr[i];
      // final adjust
      if(i===atrLen){ finalUpper[i] = upper[i]; finalLower[i] = lower[i]; continue; }
      finalUpper[i] = (upper[i] < finalUpper[i-1]) ? upper[i] : finalUpper[i-1];
      finalLower[i] = (lower[i] > finalLower[i-1]) ? lower[i] : finalLower[i-1];
      // determine trend flip
      let dirPrev = (candles[i-1].close > finalLower[i-1]) ? 1 : -1;
      let dirNow = dirPrev;
      if(candles[i].close > finalUpper[i-1]) dirNow = 1;
      else if(candles[i].close < finalLower[i-1]) dirNow = -1;
      trend[i] = dirNow;
      if(dirNow !== dirPrev){
        signals.push({ index:i, type: dirNow===1 ? 'BUY' : 'SELL', time: candles[i].time, price: candles[i].close });
      }
    }
    return { atr, finalUpper, finalLower, signals, hl2 };
  }

  function linearRegressionChannel(candles, len, mult){
    const n = candles.length;
    const center = new Array(n).fill(NaN);
    const up = new Array(n).fill(NaN);
    const low = new Array(n).fill(NaN);
    for(let i=len-1;i<n;i++){
      const slice = candles.slice(i-len+1, i+1);
      const closes = slice.map(s => s.close);
      // compute linear regression slope & intercept via least squares
      const m = len;
      let sumX=0,sumY=0,sumXY=0,sumXX=0;
      for(let k=0;k<m;k++){ sumX+=k; sumY+=closes[k]; sumXY+=k*closes[k]; sumXX+=k*k; }
      const denom = (m*sumXX - sumX*sumX);
      if(denom === 0) continue;
      const a = (m*sumXY - sumX*sumY)/denom;
      const b = (sumY - a*sumX)/m;
      const yAtEnd = a*(m-1) + b;
      center[i] = yAtEnd;
      let ss=0;
      for(let k=0;k<m;k++){ const yk = a*k + b; ss += (closes[k]-yk)*(closes[k]-yk); }
      const sd = Math.sqrt(ss/m);
      up[i] = yAtEnd + mult*sd;
      low[i] = yAtEnd - mult*sd;
    }
    return { center, up, low };
  }

  // --- draw helpers (only set points that are finite)
  function arrToSeriesForLine(candles, arr){
    const out = [];
    for(let i=0;i<candles.length;i++){
      if(Number.isFinite(arr[i])) out.push({ time: candles[i].time, value: arr[i] });
    }
    return out;
  }

  // --- load and render
  async function loadAndRender(){
    try{
      setStatus('Loading...');
      const symbol = $('symbol').value.trim() || 'CAKEUSDT';
      const interval = $('interval').value;
      const limit = Math.max(50, Math.min(1000, Number($('limit').value) || 500));
      log('Load start', {symbol, interval, limit});
      const candles = await fetchKlines(symbol, interval, limit);
      if(!chart) createChart();
      candleSeries.setData(candles);
      // LRC
      const lrcLen = Math.max(10, parseInt($('lrcLen').value)||100);
      const lrcMult = Math.max(0.1, parseFloat($('lrcMult').value)||2);
      const lrc = linearRegressionChannel(candles, lrcLen, lrcMult);
      lrcCenter.setData(arrToSeriesForLine(candles, lrc.center));
      lrcUp.setData(arrToSeriesForLine(candles, lrc.up));
      lrcLow.setData(arrToSeriesForLine(candles, lrc.low));
      // UT supertrend
      const atrLen = Math.max(2, parseInt($('atrLen').value)||14);
      const atrMult = Math.max(0.1, parseFloat($('atrMult').value)||3);
      const ut = supertrendSignals(candles, atrLen, atrMult);
      // markers
      const markers = ut.signals.map(s => ({
        time: candles[s.index].time,
        position: s.type==='BUY' ? 'belowBar' : 'aboveBar',
        color: s.type==='BUY' ? '#00d28a' : '#ff6b6b',
        shape: s.type==='BUY' ? 'arrowUp' : 'arrowDown',
        text: `${s.type}`
      }));
      candleSeries.setMarkers(markers);
      log('Rendered: candles', candles.length, 'signals', ut.signals.length);
      setStatus(`Loaded ${symbol} ${interval} (${candles.length} candles). Signals: ${ut.signals.length}`);
      $('btnReload').disabled = false;
      // scroll to rightmost
      chart.timeScale().scrollToRealTime();
    }catch(err){
      log('Load error: ' + (err.message || err));
      setStatus('Error: ' + (err.message || 'unknown'));
      $('btnReload').disabled = false;
    }
  }

  // events
  $('btnLoad').addEventListener('click', async ()=>{
    $('btnReload').disabled = true;
    try{ await loadAndRender(); }catch(e){ log('btnLoad err', e.message); }
  });
  $('btnReload').addEventListener('click', async ()=>{ $('btnReload').disabled=true; await loadAndRender(); });

  $('btnDbg').addEventListener('click', ()=>{ alert('Open browser console (F12) or use remote debugging for mobile.'); });

  // initial create + small delay then auto load (fix for mobile where container may be zero height initially)
  createChart();
  // ensure chart has correct size after layout stabilized
  setTimeout(()=> {
    try{ chart.applyOptions({ width: holder.clientWidth }); }catch(e){}
    $('btnLoad').click();
  }, 300);

  // expose for debug
  window._utfix = { createChart, loadAndRender };
})();
</script>
</body>
</html>
