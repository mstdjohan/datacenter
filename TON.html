<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>XRP Trading Bot - UT Bot + Linear Regression</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body style="font-family: Arial, sans-serif; padding:20px;">
  <h2>üìä XRP/USDT Auto Trading (UT Bot 2/10 + Linear Regression 100,2,2)</h2>
  <div>
    Live: <span id="livePrice">-</span><br>
    Trend: <span id="trend">-</span><br>
    Last Signal: <span id="lastSignal">-</span>
  </div>
  <canvas id="chart" width="800" height="400"></canvas>

  <script>
    const ctx = document.getElementById('chart').getContext('2d');
    let chart;

    async function getPricesFromCG(id, days) {
      const target = `https://api.coingecko.com/api/v3/coins/${encodeURIComponent(id)}/market_chart?vs_currency=usd&days=${days}&interval=minute`;
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(target)}`;

      const r = await fetch(proxyUrl, { cache: 'no-store' });
      if (!r.ok) throw new Error('Proxy fetch gagal');

      const wrapped = await r.json();
      const raw = JSON.parse(wrapped.contents);
      return raw.prices;
    }

    function linearRegression(data) {
      const n = data.length;
      const x = Array.from({length: n}, (_, i) => i);
      const y = data;

      const sumX = x.reduce((a,b) => a+b, 0);
      const sumY = y.reduce((a,b) => a+b, 0);
      const sumXY = x.reduce((acc, xi, i) => acc + xi*y[i], 0);
      const sumXX = x.reduce((acc, xi) => acc + xi*xi, 0);

      const slope = (n*sumXY - sumX*sumY) / (n*sumXX - sumX*sumX);
      const intercept = (sumY - slope*sumX) / n;

      return x.map((xi) => slope*xi + intercept);
    }

    function UTBot(data, key=2, atrPeriod=10) {
      let signals = [];
      for (let i = atrPeriod; i < data.length; i++) {
        const atr = Math.abs(data[i] - data[i-atrPeriod]);
        if (data[i] > data[i-1] + key*atr) {
          signals.push({index: i, type: "BUY", price: data[i]});
        } else if (data[i] < data[i-1] - key*atr) {
          signals.push({index: i, type: "SELL", price: data[i]});
        }
      }
      return signals;
    }

    async function update() {
      try {
        const pricesRaw = await getPricesFromCG("ripple", 1); // XRP
        const prices = pricesRaw.map(p => p[1]);

        document.getElementById("livePrice").textContent = "$" + prices[prices.length-1].toFixed(4);

        const lr = linearRegression(prices.slice(-100));
        const signals = UTBot(prices, 2, 10);

        if (signals.length > 0) {
          const last = signals[signals.length-1];
          document.getElementById("lastSignal").textContent = last.type + " @ $" + last.price.toFixed(4);
          document.getElementById("trend").textContent = last.type === "BUY" ? "Bullish" : "Bearish";
        }

        const labels = pricesRaw.map(p => new Date(p[0]).toLocaleTimeString());
        if (!chart) {
          chart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                { label: 'XRP/USDT', data: prices, borderColor: 'blue', fill: false },
                { label: 'Linear Regression', data: lr, borderColor: 'orange', fill: false }
              ]
            },
            options: { responsive: true }
          });
        } else {
          chart.data.labels = labels;
          chart.data.datasets[0].data = prices;
          chart.data.datasets[1].data = lr;
          chart.update();
        }

      } catch (err) {
        console.error(err);
        document.getElementById("lastSignal").textContent = "‚ùå Fetch gagal";
      }
    }

    setInterval(update, 30000);
    update();
  </script>
</body>
</html>
