<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CAKE/USDT Precision Reversal Auto-Trade</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { background:#0b0f19; color:#fff; font-family:Arial; text-align:center; }
    #chart-container { width:95%; height:500px; margin:20px auto; }
    button { margin:5px; padding:10px 20px; border:none; border-radius:8px; background:#1e88e5; color:white; cursor:pointer; }
    button:hover { background:#1565c0; }
    #status { margin-top:10px; }
  </style>
</head>
<body>
  <h2>CAKE/USDT — Precision Reversal Auto-Trader</h2>
  <div id="chart-container"><canvas id="chart"></canvas></div>
  <div>
    <button id="connectBtn">🔗 Connect Wallet</button>
    <button id="manualBuy">🟢 Manual BUY</button>
    <button id="manualSell">🔴 Manual SELL</button>
  </div>
  <div id="status">Status: <span id="walletStatus">Disconnected</span></div>

  <script>
    const pairAddress = "0x0eD7e52944161450477ee417DE9Cd3a859b14fD0";
    const routerAddress = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
    const cakeToken = "0x0E09FABB73Bd3ADE0a17ECC321fD13a19e81cE82";
    const usdtToken = "0x55d398326f99059fF775485246999027B3197955";
    let provider, signer, walletAddress;

    async function connectWallet() {
      if (!window.ethereum) return alert("MetaMask not detected");
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      walletAddress = await signer.getAddress();
      document.getElementById("walletStatus").textContent = walletAddress;
      console.log("✅ Connected:", walletAddress);
    }
    document.getElementById("connectBtn").onclick = connectWallet;

    const ctx = document.getElementById('chart').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'candlestick',
      data: { datasets: [{ label: 'CAKE/USDT', data: [] }] },
      options: {
        plugins: { legend: { labels: { color: '#fff' } } },
        scales: { x: { ticks: { color: '#fff' } }, y: { ticks: { color: '#fff' } } }
      }
    });

    function calcRSI(data, period = 14) {
      let gains = 0, losses = 0, rsi = [];
      for (let i = 1; i < data.length; i++) {
        const diff = data[i].c - data[i-1].c;
        gains += diff > 0 ? diff : 0;
        losses += diff < 0 ? -diff : 0;
        if (i >= period) {
          const avgGain = gains / period;
          const avgLoss = losses / period;
          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
          rsi.push(100 - 100 / (1 + rs));
          gains -= (data[i - period + 1].c - data[i - period].c) > 0 ? (data[i - period + 1].c - data[i - period].c) : 0;
          losses -= (data[i - period + 1].c - data[i - period].c) < 0 ? -(data[i - period + 1].c - data[i - period].c) : 0;
        }
      }
      return rsi;
    }

    function linearRegression(data, length = 100) {
      const sliced = data.slice(-length);
      const n = sliced.length;
      const sumX = sliced.reduce((a, _, i) => a + i, 0);
      const sumY = sliced.reduce((a, b) => a + b.c, 0);
      const sumXY = sliced.reduce((a, b, i) => a + i * b.c, 0);
      const sumX2 = sliced.reduce((a, _, i) => a + i * i, 0);
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      const channel = sliced.map((_, i) => ({ mid: slope * i + intercept, up: slope * i + intercept * 1.02, low: slope * i + intercept * 0.98 }));
      return channel;
    }

    async function fetchData() {
      const res = await fetch("https://api.dexscreener.com/latest/dex/pairs/bsc/" + pairAddress);
      const json = await res.json();
      const price = parseFloat(json.pair.priceUsd);
      const candle = { t: new Date(), o: price, h: price*1.001, l: price*0.999, c: price };
      chart.data.datasets[0].data.push(candle);
      if (chart.data.datasets[0].data.length > 200) chart.data.datasets[0].data.shift();
      chart.update();

      const data = chart.data.datasets[0].data;
      if (data.length < 20) return;

      const rsi = calcRSI(data);
      const lr = linearRegression(data);
      const last = data[data.length - 1];
      const lastRSI = rsi[rsi.length - 1];
      const lastLR = lr[lr.length - 1];

      if (last.c <= lastLR.low && lastRSI < 30) {
        console.log('🟢 BUY Signal');
        autoSwap('BUY');
      } else if (last.c >= lastLR.up && lastRSI > 70) {
        console.log('🔴 SELL Signal');
        autoSwap('SELL');
      }
    }

    async function getBalance(tokenAddress) {
      try {
        tokenAddress = ethers.utils.getAddress(tokenAddress);
        const erc = new ethers.Contract(tokenAddress, ["function balanceOf(address) view returns (uint256)", "function decimals() view returns (uint8)", "function allowance(address,address) view returns (uint256)", "function approve(address,uint256) returns (bool)"], signer);
        const decimals = await erc.decimals().catch(() => 18);
        let balRaw;
        try {
          balRaw = await erc.balanceOf(walletAddress);
        } catch (err) {
          balRaw = 0;
        }
        const balance = BigInt(balRaw.toString());
        return { balance, decimals };
      } catch (e) {
        console.error('⚠️ Invalid token address:', tokenAddress);
        return { balance: 0n, decimals: 18 };
      }
    }

    async function autoSwap(type) {
      if (!signer) return console.log('Wallet not connected');
      console.log(`${type} triggered (30% balance)`);
      const router = new ethers.Contract(routerAddress, ["function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256) external"], signer);
      let tokenIn = type === 'BUY' ? usdtToken : cakeToken;
      let tokenOut = type === 'BUY' ? cakeToken : usdtToken;

      const { balance, decimals } = await getBalance(tokenIn);
      if (balance === 0n) return console.log('⚠️ No balance for', tokenIn);
      const amountIn = (balance * 30n) / 100n;

      try {
        const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
          amountIn.toString(),
          0,
          [tokenIn, tokenOut],
          walletAddress,
          Math.floor(Date.now() / 1000) + 60 * 5
        );
        console.log('✅ Swap TX sent:', tx.hash);
      } catch (e) {
        console.error('❌ Swap failed:', e.message);
      }
    }

    document.getElementById('manualBuy').onclick = () => autoSwap('BUY');
    document.getElementById('manualSell').onclick = () => autoSwap('SELL');

    setInterval(fetchData, 60000);
  </script>
</body>
</html>
