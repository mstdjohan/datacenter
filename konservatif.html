<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CAKE/USDT Chart</title>
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2/dist/email.min.js"></script>
  <style>
    body { background:#111; color:#eee; font-family:sans-serif; }
    #chart { height:500px; }
    #controls { margin:10px; }
    button { margin:5px; }
  </style>
</head>
<body>
  <h2>CAKE/USDT Live Chart + UT Bot + Regression + EmailJS + SL/TP</h2>
  <div id="chart"></div>
  <div id="controls">
    <button onclick="toggleLive()">Toggle Live</button>
    <span id="status"></span>
  </div>

<script>
// ==== EmailJS init ====
emailjs.init("YOUR_USER_ID"); // Ganti dengan User ID EmailJS

// ==== Config ====
let symbol = "CAKEUSDT";
let interval = "15m";
let live = true;
let chart, candleSeries, utSeries, upperSeries, lowerSeries, regSeries;

const slRatio = -0.02; // -2%
const tpRatio = 0.04;  // +4%

// ==== Chart Init ====
chart = LightweightCharts.createChart(document.getElementById("chart"), {
  layout:{background:{color:'#111'}, textColor:'#eee'},
  grid:{vertLines:{color:'#333'}, horzLines:{color:'#333'}},
});
candleSeries = chart.addCandlestickSeries();
utSeries = chart.addLineSeries({color:'yellow'});
regSeries = chart.addLineSeries({color:'cyan'});
upperSeries = chart.addLineSeries({color:'red'});
lowerSeries = chart.addLineSeries({color:'red'});

// ==== Robust fetch ====
async function robustFetchKlines(sym, intv, limit=500) {
  const hosts = ["https://api.binance.com", "https://api1.binance.com", "https://api2.binance.com"];
  for (let h of hosts) {
    try {
      const url = `${h}/api/v3/klines?symbol=${sym}&interval=${intv}&limit=${limit}`;
      console.log("Fetching:", url);
      const res = await fetch(url);
      if (!res.ok) throw new Error("Status " + res.status);
      const raw = await res.json();
      console.log("Klines data sample:", raw.slice(-3));
      return raw.map(k=>({time: k[0]/1000, open: +k[1], high:+k[2], low:+k[3], close:+k[4]}));
    } catch(e) {
      console.error("Fetch fail at host", h, e);
    }
  }
  return [];
}

// ==== ATR Helper ====
function atr(data, period=10) {
  let trs=[];
  for (let i=1;i<data.length;i++) {
    let hi = data[i].high, lo=data[i].low, pc=data[i-1].close;
    trs.push(Math.max(hi-lo, Math.abs(hi-pc), Math.abs(lo-pc)));
  }
  let out=[];
  for (let i=period;i<trs.length;i++) {
    let slice=trs.slice(i-period,i);
    out.push(slice.reduce((a,b)=>a+b,0)/period);
  }
  return Array(data.length-out.length).fill(null).concat(out);
}

// ==== UT Bot Logic ====
function utBot(data, atrPeriod=10, mult=2) {
  let atrVals=atr(data, atrPeriod);
  let signals=[], line=[];
  let trend=null;
  for (let i=0;i<data.length;i++) {
    if (!atrVals[i]) { line.push(null); continue; }
    let src=data[i].close;
    let buy=src > data[i].close - mult*atrVals[i];
    if (buy && trend!=="up") { signals.push({time:data[i].time, text:"BUY", price:src}); trend="up"; }
    else if (!buy && trend!=="down") { signals.push({time:data[i].time, text:"SELL", price:src}); trend="down"; }
    line.push({time:data[i].time, value:src});
  }
  console.log("UT Signals:", signals.slice(-5));
  return {signals,line};
}

// ==== Regression Channel ====
function regressionChannel(data, length=100, dev=2) {
  if (data.length<length) return {center:[],upper:[],lower:[]};
  let closes=data.slice(-length).map(c=>c.close);
  let times=data.slice(-length).map(c=>c.time);
  let n=closes.length;
  let avgX=times.reduce((a,b)=>a+b,0)/n;
  let avgY=closes.reduce((a,b)=>a+b,0)/n;
  let num=0,den=0;
  for (let i=0;i<n;i++){num+=(times[i]-avgX)*(closes[i]-avgY);den+=(times[i]-avgX)**2;}
  let slope=num/den;
  let intercept=avgY-slope*avgX;
  let center=times.map((t,i)=>({time:t,value:slope*t+intercept}));
  let residuals=closes.map((y,i)=>y-(slope*times[i]+intercept));
  let std=Math.sqrt(residuals.reduce((a,b)=>a+b*b,0)/n);
  let upper=center.map(p=>({time:p.time,value:p.value+dev*std}));
  let lower=center.map(p=>({time:p.time,value:p.value-dev*std}));
  console.log("Regression sample:", center.slice(-3));
  return {center,upper,lower};
}

// ==== EmailJS Send ====
function sendSignalMail(signal, sl, tp) {
  console.log("Sending EmailJS:", signal.text, "Price:", signal.price, "SL:", sl, "TP:", tp);
  emailjs.send("YOUR_SERVICE_ID", "YOUR_TEMPLATE_ID", {
    message: `${signal.text} at ${signal.price}\nSL: ${sl}\nTP: ${tp}`
  }).then(r=>console.log("Email sent", r), e=>console.error("Email fail", e));
}

// ==== Main Load ====
async function loadAll(){
  try {
    const ohlc=await robustFetchKlines(symbol, interval);
    if (!ohlc || !ohlc.length) { 
      document.getElementById("status").textContent="No data loaded.";
      console.warn("OHLC empty");
      return;
    }
    console.log("OHLC count:", ohlc.length);
    candleSeries.setData(ohlc);

    let ut=utBot(ohlc);
    utSeries.setData(ut.line.filter(Boolean));
    ut.signals.forEach(sig=>{
      let sl = sig.price*(1+slRatio);
      let tp = sig.price*(1+tpRatio);
      sendSignalMail(sig, sl.toFixed(4), tp.toFixed(4));
    });

    let reg=regressionChannel(ohlc);
    regSeries.setData(reg.center);
    upperSeries.setData(reg.upper);
    lowerSeries.setData(reg.lower);
    document.getElementById("status").textContent="Data Loaded";
  } catch(e){
    document.getElementById("status").textContent='Gagal memuat data.';
    console.error("LoadAll error:", e);
  }
}

function toggleLive(){ live=!live; console.log("Live mode:", live); }

loadAll();
setInterval(()=>{ if(live) loadAll(); }, 10000);
</script>
</body>
</html>
