<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRP↔USDT Auto Trader (BSC Mainnet) — Auto-Fill + Slippage + TrustWallet Price Filter</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:#071024;color:#e6eef8;margin:0;padding:20px}
    .wrap{max-width:1000px;margin:0 auto}
    .card{background:linear-gradient(180deg,#081428,#06101a);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,.05)}
    h1{margin:0 0 10px;font-size:20px}
    label{display:block;margin-top:10px;color:#9fb0d0;font-size:13px}
    input,select,button{width:100%;padding:10px;margin-top:6px;border-radius:10px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.03);color:inherit}
    .row{display:flex;gap:12px}
    .col{flex:1}
    .small{font-size:13px;color:#99b3d6}
    pre{white-space:pre-wrap;word-break:break-word;background:transparent;padding:8px}
    .muted{color:#7f9ec8}
    .pill{display:flex;gap:8px;margin-top:8px}
    .pill button{flex:1;padding:8px;border-radius:999px}
    @media(max-width:880px){.row{flex-direction:column}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>XRP ↔ USDT Auto Trader — Auto-Fill + TrustWallet Price Filter</h1>
      <div class="small muted">Mainnet (real trades). Harga utama dari <code>router.getAmountsOut()</code> PancakeSwap; verifikasi terhadap <strong>mid-price</strong> & <strong>TrustWallet API</strong>. Transaksi <u>dibatalkan otomatis</u> bila deviasi melewati ambang.</div>

      <label>Mode</label>
      <select id="mode">
        <option value="buy">Buy (USDT → XRP)</option>
        <option value="sell">Sell (XRP → USDT)</option>
      </select>

      <label>Connect Wallet</label>
      <div class="row">
        <input id="address" placeholder="Belum terhubung" readonly />
        <div style="width:160px"><button id="btnConnect">Connect</button></div>
      </div>

      <label>Network & BNB</label>
      <div class="row">
        <input id="network" placeholder="—" readonly />
        <input id="balance" placeholder="—" readonly />
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.08)" />

      <label>Auto-selected Tokens (BEP20 on BSC)</label>
      <div class="row">
        <div class="col"><input id="tokenFrom" readonly /></div>
        <div style="width:220px"><input id="decFrom" placeholder="decimals" readonly /></div>
      </div>
      <div class="row">
        <div class="col"><input id="tokenTo" readonly /></div>
        <div style="width:220px"><input id="decTo" placeholder="decimals" readonly /></div>
      </div>

      <label>Saldo Token (otomatis)</label>
      <div class="row">
        <input id="tokenBalance" placeholder="—" readonly />
        <div style="width:220px"><input id="tokenSymbol" placeholder="symbol" readonly /></div>
      </div>

      <label>Amount (amount of source token to trade)</label>
      <input id="amount" placeholder="otomatis: 100% dari saldo" />
      <div class="pill">
        <button type="button" data-pct="25" class="pct">25%</button>
        <button type="button" data-pct="50" class="pct">50%</button>
        <button type="button" data-pct="75" class="pct">75%</button>
        <button type="button" data-pct="100" class="pct">100%</button>
      </div>

      <label>Targets (harga USDT per 1 XRP)</label>
      <div class="row">
        <div class="col"><input id="tp1" placeholder="TP1" /></div>
        <div class="col"><input id="tp2" placeholder="TP2 (optional)" /></div>
        <div class="col"><input id="tp3" placeholder="TP3 (optional)" /></div>
      </div>
      <label>Stop Loss (SL)</label>
      <input id="sl" placeholder="SL" />

      <div class="row">
        <div class="col">
          <label>Slippage tolerance (%)</label>
          <input id="slippage" placeholder="0.1" value="0.1" />
        </div>
        <div class="col">
          <label>Max dev vs Mid (%)</label>
          <input id="maxDevMid" placeholder="1.0" value="1.0" />
        </div>
        <div class="col">
          <label>Max dev vs Trust (%)</label>
          <input id="maxDevTrust" placeholder="1.0" value="1.0" />
        </div>
      </div>

      <label>TrustWallet Price (USDT per XRP)</label>
      <div class="row">
        <div class="col"><input id="trustPrice" placeholder="(auto)" readonly /></div>
        <div class="col"><input id="trustEndpoint" placeholder="(opsional) override endpoint TrustWallet API" /></div>
        <div style="width:200px"><label><input type="checkbox" id="useTrust" checked /> Gunakan TrustWallet filter</label></div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button id="btnStart" disabled>Start Bot</button>
        <button id="btnStop" disabled>Stop Bot</button>
      </div>

      <div style="margin-top:12px">
        <div class="small muted">Status</div>
        <div id="status">idle</div>
        <label style="margin-top:8px">Logs</label>
        <pre id="log">— ready —</pre>
      </div>

      <div style="margin-top:14px;color:#ffd1a9;font-size:13px">
        <strong>PERINGATAN:</strong> Ini melakukan transaksi nyata di BSC Mainnet saat Start ditekan. Uji dengan nominal kecil dulu. Risiko tanggung sendiri.
      </div>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.12/dist/index.js"></script>

  <script>
  'use strict';
  window.addEventListener('load', function(){
    // ===== Constants
    const BSC_CHAIN_ID = 56;
    const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
    const WBNB = '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';
    const USDT = '0x55d398326f99059fF775485246999027B3197955';
    const XRP_BEP20 = '0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE';
    const ERC20_ABI_MIN = [
      'function decimals() view returns (uint8)',
      'function symbol() view returns (string)',
      'function balanceOf(address) view returns (uint256)',
      'function allowance(address owner, address spender) view returns (uint256)',
      'function approve(address spender, uint256 amount) returns (bool)'
    ];

    // ===== Elements & utils
    const el = id => document.getElementById(id);
    function safeLog(msg){
      try{ el('log').textContent = new Date().toLocaleTimeString() + ' — ' + String(msg) + '\n' + el('log').textContent; }catch(e){}
      try{ console.log(msg); }catch(_){}
    }
    const fmt = (n, d=6) => Number(n).toLocaleString(undefined,{maximumFractionDigits:d});
    const pctDiff = (a,b)=> (b===0||!isFinite(a)||!isFinite(b))? Infinity : ( (a-b)/b*100 );

    // ===== State
    let rawProvider = null;   // provider dari web3modal/window.ethereum
    let web3Provider = null;  // ethers provider
    let signer = null;
    let account = null;
    let botInterval = null;
    let pollInterval = null;
    let balancePoll = null;
    let lastSourceBalance = null; // in human units

    // ===== Event API safety (fix for "read 'emit'")
    function addNoop(obj, name){ if(!obj) return; if(typeof obj[name] !== 'function'){ try{ obj[name] = function(){}; }catch(e){} } }
    function ensureEventAPI(obj){ if(!obj) return obj; addNoop(obj,'on'); addNoop(obj,'off'); addNoop(obj,'once'); addNoop(obj,'removeListener'); addNoop(obj,'emit'); return obj; }
    function patchProvider(p){ if(!p) return null; ensureEventAPI(p); try{ if(p.connector==null) p.connector={}; ensureEventAPI(p.connector);}catch(_){} try{ if(p.wc==null) p.wc={}; ensureEventAPI(p.wc);}catch(_){} return p; }

    // ===== Web3Modal init (guarded)
    let web3Modal = null;
    try{
      const Web3ModalCtor = window.Web3Modal && (window.Web3Modal.default || window.Web3Modal);
      if(Web3ModalCtor){
        web3Modal = new Web3ModalCtor({
          cacheProvider:false,
          providerOptions:{
            walletconnect:{
              package: (window.WalletConnectProvider && (window.WalletConnectProvider.default||window.WalletConnectProvider)) || undefined,
              options: { rpc: { 56: 'https://bsc-dataseed.binance.org/' } }
            }
          }
        });
      }
    }catch(e){ safeLog('Web3Modal init error: '+e); }

    // ===== Mode & tokens
    function applyMode(){
      const mode = el('mode').value;
      if(mode === 'buy'){ el('tokenFrom').value = USDT; el('tokenTo').value = XRP_BEP20; }
      else { el('tokenFrom').value = XRP_BEP20; el('tokenTo').value = USDT; }
      el('decFrom').value = '';
      el('decTo').value = '';
      if(web3Provider && signer){ refreshTokenMetaAndBalance().catch(e=>safeLog('applyMode refresh error: '+e)); }
    }
    el('mode').addEventListener('change', applyMode);

    // ===== Read token metadata
    async function readDecimals(token){
      const erc = new ethers.Contract(token, ERC20_ABI_MIN, web3Provider);
      const d = await erc.decimals();
      return Number(d);
    }
    async function readSymbol(token){
      try{ const erc = new ethers.Contract(token, ERC20_ABI_MIN, web3Provider); return await erc.symbol(); }
      catch(e){ return token===USDT?'USDT':(token===XRP_BEP20?'XRP':'TOKEN'); }
    }

    // ===== Balance helpers
    async function getTokenBalance(token, who){
      const erc = new ethers.Contract(token, ERC20_ABI_MIN, web3Provider);
      const [dec, raw] = await Promise.all([
        readDecimals(token),
        erc.balanceOf(who)
      ]);
      const human = Number(ethers.utils.formatUnits(raw, dec));
      return {dec, raw, human};
    }
    async function autoFillAmountFromBalance(percent=100){
      try{
        const mode = el('mode').value;
        const source = (mode==='buy') ? USDT : XRP_BEP20;
        const sym = await readSymbol(source);
        const bal = await getTokenBalance(source, account);
        lastSourceBalance = bal.human;
        const take = (Number(percent)||100)/100 * bal.human;
        el('tokenBalance').value = `${fmt(bal.human)} ${sym}`;
        el('tokenSymbol').value = sym;
        el('amount').value = take>0 ? String(take) : '';
        el('decFrom').value = bal.dec; // fill decimals for source
        el('decTo').value = await readDecimals((mode==='buy')?XRP_BEP20:USDT);
      }catch(e){ safeLog('autoFill error: '+e); }
    }

    // ===== Router price helpers
    function displayPath(path){ return (Array.isArray(path) && path.length>0) ? path.join(' → ') : '(no path found)'; }
    async function getBestOut(tokenIn, tokenOut, amountInBN){
      const router = new ethers.Contract(
        PANCAKE_ROUTER,
        ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'],
        web3Provider
      );
      const tryPath = async (path)=>{ try{ const arr = await router.getAmountsOut(amountInBN, path); return arr[arr.length-1]; }catch(e){ return null; } };
      const direct = await tryPath([tokenIn, tokenOut]);
      const viaWbnb = await tryPath([tokenIn, WBNB, tokenOut]);
      if(direct && viaWbnb) return direct.gt(viaWbnb) ? {out:direct, path:[tokenIn, tokenOut]} : {out:viaWbnb, path:[tokenIn, WBNB, tokenOut]};
      if(direct) return {out:direct, path:[tokenIn, tokenOut]};
      if(viaWbnb) return {out:viaWbnb, path:[tokenIn, WBNB, tokenOut]};
      return {out:null, path:[]};
    }

    async function getPriceUSDTperXRP(slippagePct){
      const mode = el('mode').value;
      const tokenFrom = el('tokenFrom').value;
      const tokenTo = el('tokenTo').value;
      const decIn = await readDecimals(tokenFrom);
      const decOut = await readDecimals(tokenTo);
      const amountHuman = Number(el('amount').value)||1; // gunakan amount sebenarnya agar simulasi realistis
      const amountInBN = ethers.utils.parseUnits(String(amountHuman), decIn);

      const bestDir = await getBestOut(tokenFrom, tokenTo, amountInBN);
      if(!bestDir || !bestDir.out){
        return { routerUSDTperXRP: NaN, execUSDTperXRP: NaN, oneFrom_toTo: null, midUSDTperXRP: null, bestPath: [] };
      }
      const outHuman = Number(ethers.utils.formatUnits(bestDir.out, decOut));

      let routerUSDTperXRP;
      if(mode === 'buy'){
        // amountHuman USDT -> outHuman XRP  ⇒ price = USDT/XRP
        routerUSDTperXRP = amountHuman / (outHuman || 1);
      }else{
        // amountHuman XRP -> outHuman USDT ⇒ price = USDT/XRP
        routerUSDTperXRP = (outHuman || 0) / amountHuman;
      }

      // Mid-price estimator
      const usdtProbe = ethers.utils.parseUnits('1', await readDecimals(USDT));
      const xrpProbe  = ethers.utils.parseUnits('1', await readDecimals(XRP_BEP20));
      const bestBuy   = await getBestOut(USDT, XRP_BEP20, usdtProbe); // USDT -> XRP
      const bestSell  = await getBestOut(XRP_BEP20, USDT, xrpProbe);  // XRP -> USDT
      let midUSDTperXRP = null;
      if(bestBuy.out && bestSell.out){
        const buyXrpOut = Number(ethers.utils.formatUnits(bestBuy.out, await readDecimals(XRP_BEP20))); // XRP
        const sellUsdtOut = Number(ethers.utils.formatUnits(bestSell.out, await readDecimals(USDT)));  // USDT
        const priceBuy = 1 / (buyXrpOut || 1);   // USDT per 1 XRP (from buy small amount)
        const priceSell = (sellUsdtOut || 0) / 1;// USDT per 1 XRP (from sell small amount)
        midUSDTperXRP = (priceBuy + priceSell) / 2;
      }

      const slip = Math.max(0, Number(slippagePct)||0);
      const execUSDTperXRP = routerUSDTperXRP * (1 - slip/100);

      return { routerUSDTperXRP, execUSDTperXRP, oneFrom_toTo: outHuman, midUSDTperXRP, bestPath: bestDir.path };
    }

    // ===== TrustWallet price fetcher (best-effort, beberapa endpoint umum)
    async function fetchTrustPriceUSDTperXRP(){
      const override = el('trustEndpoint').value.trim();
      const addr = 'bnb-smart-chain:0x1d2f0da169ceb9fc7b3144628db156f3f6c60dbe';
      const candidates = [];
      if(override) candidates.push(override.replace('{address}', addr));
      // Beberapa pola endpoint publik yang umum dipakai TrustWallet infra (akan dicoba berurutan)
      candidates.push(`https://prices.trustwallet.com/price?currency=USD&tokens=${encodeURIComponent(addr)}`);
      candidates.push(`https://market-api.trustwallet.com/v1/market/price?asset=${encodeURIComponent(addr)}&currency=usd`);
      candidates.push(`https://api.trustwallet.com/prices?assets=${encodeURIComponent(addr)}`);

      for(const url of candidates){
        try{
          const r = await fetch(url, {mode:'cors'});
          if(!r.ok) continue;
          const j = await r.json();
          // Coba beberapa bentuk struktur umum
          // 1) { prices: { "bnb-smart-chain:addr": { price: 0.5 } } }
          if(j && j.prices){
            const p = j.prices[addr] || j.prices[addr.toUpperCase()] || j.prices[addr.toLowerCase()];
            if(p && typeof p.price === 'number' && p.price>0) return p.price; // USD per XRP
          }
          // 2) { asset:"...", price: 0.5 }
          if(j && typeof j.price === 'number' && j.price>0) return j.price;
          // 3) { data: { price: 0.5 } }
          if(j && j.data && typeof j.data.price === 'number' && j.data.price>0) return j.data.price;
          // 4) { [addr]: 0.5 }
          if(j && typeof j[addr] === 'number' && j[addr]>0) return j[addr];
        }catch(e){ /* CORS/format mismatch — coba endpoint berikutnya */ }
      }
      throw new Error('TrustWallet price unavailable');
    }

    async function readAndShowTrustPrice(){
      try{
        const usdPerXrp = await fetchTrustPriceUSDTperXRP();
        el('trustPrice').value = usdPerXrp;
        return usdPerXrp;
      }catch(e){ el('trustPrice').value = '(unavailable)'; safeLog('Trust price error: '+e.message); return null; }
    }

    // ===== Approve & Swap (best route/DEX)
    async function approveIfNeeded(token, spender, amountHuman){
      const {dec} = await getTokenBalance(token, account);
      const erc = new ethers.Contract(token, ERC20_ABI_MIN, signer);
      const allowance = await erc.allowance(account, spender);
      const amount = ethers.utils.parseUnits(String(amountHuman), dec);
      if(allowance.gte(amount)) { safeLog('Allowance ok'); return true; }
      const tx = await erc.approve(spender, ethers.constants.MaxUint256);
      safeLog('Approve sent: ' + tx.hash);
      await tx.wait(); safeLog('Approve confirmed'); return true;
    }
    async function swapExactTokensBest(tokenIn, tokenOut, amountInHuman, slippagePercent){
      const decIn = await readDecimals(tokenIn);
      const router = new ethers.Contract(
        PANCAKE_ROUTER,
        [
          'function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)',
          'function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external'
        ], signer);
      const amountIn = ethers.utils.parseUnits(String(amountInHuman), decIn);
      const best = await getBestOut(tokenIn, tokenOut, amountIn);
      if(!best || !best.out || !Array.isArray(best.path) || best.path.length===0){
        throw new Error('No valid route for swap');
      }
      const estOut = best.out;
      const slipBps = Math.floor((Number(slippagePercent)||0.1) * 100);
      const amountOutMin = estOut.mul(10000 - slipBps).div(10000);
      await approveIfNeeded(tokenIn, PANCAKE_ROUTER, amountInHuman);
      const deadline = Math.floor(Date.now()/1000) + 60*10;
      const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
        amountIn, amountOutMin, best.path, account, deadline, { gasLimit: 800000 }
      );
      safeLog('Swap via: ' + displayPath(best.path));
      safeLog('Swap sent: ' + tx.hash);
      const receipt = await tx.wait();
      safeLog('Swap confirmed: ' + receipt.transactionHash);
      return receipt;
    }

    // ===== Connect
    async function connect(){
      if(!web3Modal && !window.ethereum){ alert('Web3Modal/window.ethereum tidak tersedia'); return; }
      try{
        rawProvider = null;
        if(web3Modal){ try{ rawProvider = await web3Modal.connect(); } catch(e){ safeLog('web3Modal.connect error: '+e); } }
        if(!rawProvider && window.ethereum){ rawProvider = window.ethereum; safeLog('Using window.ethereum fallback'); }
        if(!rawProvider){ alert('Provider tidak ditemukan. Aktifkan Trust Wallet/MetaMask.'); return; }

        patchProvider(rawProvider); // fix for 'emit'
        web3Provider = new ethers.providers.Web3Provider(rawProvider, 'any');
        signer = web3Provider.getSigner();
        try{ account = await signer.getAddress(); }catch(e){ account = null; }
        if(account) el('address').value = account;
        const net = await web3Provider.getNetwork(); el('network').value = net.name + ' (' + net.chainId + ')';
        const bnb = account ? await web3Provider.getBalance(account) : null; el('balance').value = bnb ? (fmt(ethers.utils.formatEther(bnb),6) + ' BNB') : '—';
        if(Number(net.chainId)!==BSC_CHAIN_ID){ alert('Switch ke Binance Smart Chain (Mainnet).'); safeLog('Non-BSC network detected: '+net.chainId); }

        await refreshTokenMetaAndBalance();
        el('btnStart').disabled = false; el('btnStop').disabled = false;

        if(pollInterval) clearInterval(pollInterval);
        pollInterval = setInterval(async ()=>{
          try{
            const newNet = await web3Provider.getNetwork(); el('network').value = newNet.name + ' (' + newNet.chainId + ')';
            const newAcc = await signer.getAddress(); if(newAcc && newAcc !== account){ account = newAcc; el('address').value = account; safeLog('account changed'); await refreshTokenMetaAndBalance(); }
            if(account){ const bnb2 = await web3Provider.getBalance(account); el('balance').value = fmt(ethers.utils.formatEther(bnb2),6) + ' BNB'; }
          }catch(e){ /* ignore */ }
        }, 3500);

        if(balancePoll) clearInterval(balancePoll);
        balancePoll = setInterval(async ()=>{ try{ if(account) await autoFillAmountFromBalance(100); }catch(e){} }, 10000);

        // Baca Trust price pertama kali
        readAndShowTrustPrice();

        safeLog('Connected');
      }catch(e){ safeLog('connect error: '+e); }
    }

    async function refreshTokenMetaAndBalance(){
      try{
        const mode = el('mode').value;
        if(mode==='buy'){ el('tokenFrom').value = USDT; el('tokenTo').value = XRP_BEP20; }
        else { el('tokenFrom').value = XRP_BEP20; el('tokenTo').value = USDT; }
        const decF = await readDecimals(el('tokenFrom').value); el('decFrom').value = decF;
        const decT = await readDecimals(el('tokenTo').value); el('decTo').value = decT;
        await autoFillAmountFromBalance(100); // FULL auto-fill
      }catch(e){ safeLog('refresh meta/balance error: '+e); }
    }

    // ===== Bot Loop
    async function checkAndAct(){
      try{
        if(!web3Provider || !signer){ safeLog('Provider/signature not ready'); return; }
        const net = await web3Provider.getNetwork(); if(Number(net.chainId)!==BSC_CHAIN_ID){ safeLog('Not on BSC — skipping check'); return; }
        const tokenFrom = el('tokenFrom').value; const tokenTo = el('tokenTo').value; if(!ethers.utils.isAddress(tokenFrom) || !ethers.utils.isAddress(tokenTo)){ safeLog('Invalid token addresses'); return; }
        const amount = Number(el('amount').value); if(!amount || amount<=0){ safeLog('Invalid amount'); return; }

        const tp1 = Number(el('tp1').value) || null; const tp2 = Number(el('tp2').value) || null; const tp3 = Number(el('tp3').value) || null; const sl = Number(el('sl').value) || null; const slippage = Number(el('slippage').value) || 0.1;
        const maxDevMid = Number(el('maxDevMid').value)||1.0; const maxDevTrust = Number(el('maxDevTrust').value)||1.0; const useTrust = el('useTrust').checked;

        const prices = await getPriceUSDTperXRP(slippage);
        const { routerUSDTperXRP, execUSDTperXRP, oneFrom_toTo, midUSDTperXRP, bestPath } = prices;
        if(!isFinite(routerUSDTperXRP) || !isFinite(execUSDTperXRP) || oneFrom_toTo==null){
          safeLog(`No valid quote available. Path: ${displayPath(bestPath)} — skip`);
          return;
        }

        // TrustWallet price (optional)
        let trust = null;
        if(useTrust){ trust = await readAndShowTrustPrice(); }

        const mode = el('mode').value;
        const devMid = (midUSDTperXRP? pctDiff(routerUSDTperXRP, midUSDTperXRP) : null);
        const devTrust = (trust? pctDiff(routerUSDTperXRP, trust) : null);

        if(mode === 'buy'){
          safeLog(`Best: ${displayPath(bestPath)} | 1 USDT → ${oneFrom_toTo} XRP | Dir ${routerUSDTperXRP} | Mid ~ ${midUSDTperXRP} | Trust ${trust??'(n/a)'} | Exec ${execUSDTperXRP} (slip ${slippage}%) | DevMid ${devMid?.toFixed?devMid.toFixed(3):'(n/a)'}% | DevTrust ${devTrust?.toFixed?devTrust.toFixed(3):'(n/a)'}%`);
        } else {
          safeLog(`Best: ${displayPath(bestPath)} | 1 XRP → ${oneFrom_toTo} USDT | Dir ${routerUSDTperXRP} | Mid ~ ${midUSDTperXRP} | Trust ${trust??'(n/a)'} | Exec ${execUSDTperXRP} (slip ${slippage}%) | DevMid ${devMid?.toFixed?devMid.toFixed(3):'(n/a)'}% | DevTrust ${devTrust?.toFixed?devTrust.toFixed(3):'(n/a)'}%`);
        }

        // ==== Guards: batalkan bila deviasi berlebihan
        if(isFinite(devMid) && Math.abs(devMid) > maxDevMid){ safeLog(`Skip: deviation vs mid ${devMid.toFixed(3)}% > ${maxDevMid}%`); return; }
        if(useTrust && isFinite(devTrust) && Math.abs(devTrust) > maxDevTrust){ safeLog(`Skip: deviation vs Trust ${devTrust.toFixed(3)}% > ${maxDevTrust}%`); return; }

        // ==== TP/SL logic
        if(mode === 'sell'){
          if(tp1 && execUSDTperXRP >= tp1){ safeLog('TP1 hit — SELL'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp1').value=''; return; }
          if(tp2 && execUSDTperXRP >= tp2){ safeLog('TP2 hit — SELL'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp2').value=''; return; }
          if(tp3 && execUSDTperXRP >= tp3){ safeLog('TP3 hit — SELL'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp3').value=''; return; }
          if(sl && execUSDTperXRP <= sl){ safeLog('SL hit — SELL'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); return; }
        } else {
          if(tp1 && execUSDTperXRP <= tp1){ safeLog('TP1 hit — BUY'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp1').value=''; return; }
          if(tp2 && execUSDTperXRP <= tp2){ safeLog('TP2 hit — BUY'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp2').value=''; return; }
          if(tp3 && execUSDTperXRP <= tp3){ safeLog('TP3 hit — BUY'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); el('tp3').value=''; return; }
          if(sl && execUSDTperXRP >= sl){ safeLog('SL hit — BUY (stop)'); await swapExactTokensBest(tokenFrom, tokenTo, amount, slippage); return; }
        }
      }catch(e){ safeLog('bot error: ' + e); }
    }

    // ===== UI Actions
    document.querySelectorAll('.pct').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const pct = Number(btn.getAttribute('data-pct'))||100;
        autoFillAmountFromBalance(pct).catch(e=>safeLog('pct click error: '+e));
      });
    });

    el('btnConnect').addEventListener('click', async ()=>{
      // toggle connect/disconnect
      if(!rawProvider){ await connect(); return; }
      try{ if(rawProvider && typeof rawProvider.disconnect==='function') await rawProvider.disconnect(); }catch(e){}
      rawProvider=null; web3Provider=null; signer=null; account=null;
      el('address').value=''; el('network').value=''; el('balance').value='';
      el('btnStart').disabled=true; el('btnStop').disabled=true;
      if(pollInterval){clearInterval(pollInterval);pollInterval=null;}
      if(balancePoll){clearInterval(balancePoll);balancePoll=null;}
      safeLog('Disconnected');
    });

    el('btnStart').addEventListener('click', async ()=>{
      if(!web3Provider || !signer){ alert('Connect wallet terlebih dahulu'); return; }
      const net = await web3Provider.getNetwork(); if(Number(net.chainId)!==BSC_CHAIN_ID){ alert('Switch ke BSC Mainnet di wallet Anda'); return; }
      try{ await readDecimals(el('tokenFrom').value); await readDecimals(el('tokenTo').value);}catch(e){ alert('Token tidak valid di jaringan ini: '+e); return; }
      el('status').textContent = 'Bot running'; safeLog('Bot started');
      if(botInterval) clearInterval(botInterval);
      botInterval = setInterval(checkAndAct, 8000);
      checkAndAct();
      el('btnStart').disabled = true; el('btnStop').disabled = false;
    });

    el('btnStop').addEventListener('click', ()=>{
      if(botInterval){ clearInterval(botInterval); botInterval=null; el('status').textContent='Bot stopped'; safeLog('Bot stopped'); el('btnStop').disabled=true; el('btnStart').disabled=false; }
      else { alert('Bot tidak berjalan'); }
    });

    // Init default UI
    applyMode();

    // ===== Self-tests (tidak mengganggu trading)
    try{
      // Test A: displayPath aman untuk undefined/null/[]/valid
      safeLog('TEST displayPath(undefined): ' + displayPath(undefined));
      safeLog('TEST displayPath([]): ' + displayPath([]));
      safeLog('TEST displayPath(["A","B"]): ' + displayPath(['A','B']));

      // Test B: provider patch
      const fake1 = {}; patchProvider(fake1); safeLog('TEST patchProvider({}) ok');

      // Test C: dev calc
      const a=4.0,b=3.96; const d = pctDiff(a,b); safeLog('TEST pctDiff(4.0,3.96) ≈ '+d.toFixed(3)+'%');
    }catch(e){ safeLog('Self-test error: '+e); }
  });
  </script>
</body>
</html>
