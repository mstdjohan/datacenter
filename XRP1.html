<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UT Bot CAKE/USDT — Final (EmailJS)</title>

  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
  <!-- EmailJS -->
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>

  <style>
    :root{--bg:#07121a;--panel:#0b1820;--muted:#9fb4c9;--text:#e6f6ff;--ok:#22c55e;--bad:#ef4444}
    body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);padding:14px}
    .wrap{max-width:1100px;margin:0 auto}
    .card{background:var(--panel);border-radius:12px;padding:12px;border:1px solid #0f2430}
    header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
    h1{font-size:16px;margin:0}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    input,select,button{padding:8px;border-radius:8px;border:1px solid #123140;background:#08121a;color:var(--text)}
    button{cursor:pointer}
    button.primary{background:var(--ok);color:#04160a;border:0;font-weight:700}
    #chart{height:520px;border-radius:8px;overflow:hidden}
    .log{height:200px;overflow:auto;background:#051016;border:1px solid #0f2833;border-radius:8px;padding:8px;font-family:ui-monospace,monospace;font-size:13px;margin-top:12px}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
    label.small{font-size:13px;color:var(--muted)}
    .pill{padding:6px 10px;border-radius:999px;background:#081923;border:1px solid #153241;color:var(--muted);font-size:12px}
    .note{font-size:13px;color:var(--muted);margin-top:6px}
    @media(max-width:900px){#chart{height:360px}.grid{grid-template-columns:1fr 1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>UT Bot • CAKE/USDT (KV=1, ATR=10) — Final</h1>
      <div class="note">Sinyal dikirim via EmailJS saat terdeteksi (1x per bar). Juga dikirim sebelum confirm saat eksekusi.</div>
    </div>
    <div class="controls">
      <div class="pill">Pair: CAKE/USDT</div>
      <select id="tfSelect">
        <option value="1m">1m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="1h">1h</option>
      </select>
      <button id="btnLoad" class="primary">Load Now</button>
    </div>
  </header>

  <div class="card">
    <div id="chart"></div>

    <div class="grid" style="margin-top:10px">
      <div>
        <label class="small">Polling override (sec)</label>
        <input id="pollSec" type="number" value="0" min="0" placeholder="0 = auto">
        <div class="note">Default auto per TF (1m=10s,5m=30s,15m=60s,1h=180s)</div>
      </div>
      <div>
        <label class="small">Candles to fetch (limit)</label>
        <input id="limit" type="number" value="600" min="100" max="1000">
      </div>
      <div>
        <label class="small">Minimal Gap % (minGap)</label>
        <input id="minGap" type="number" value="1" step="0.1" min="0">
        <div class="note">Jika entryPrice ada, sinyal diabaikan bila selisih &lt; minGap%</div>
      </div>
    </div>

    <div style="height:8px"></div>

    <div class="card" style="margin-top:8px">
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <label class="small">service_5hxo1hk</label>
        <input id="emailService" placeholder="your_service_id" style="width:180px" value="your_service_id">
        <label class="small">template_iq87egh</label>
        <input id="emailTemplate" placeholder="template_utbot" style="width:180px" value="template_utbot">
        <label class="small">OGH12a8LlCboHPVz8</label>
        <input id="emailUser" placeholder="your_public_key" style="width:180px" value="your_public_key">
        <button id="btnSaveEmail">Save</button>
        <button id="btnTestEmail" disabled>Test Email</button>
      </div>
      <div class="note">Gunakan template EmailJS dengan variable: signalType, signalClass, pair, price, volume, estimation, time</div>
    </div>

    <div class="log" id="log"></div>
  </div>
</div>

<script>
/* Final single-file UT Bot + EmailJS
   - Default placeholders: service=your_service_id, template=template_utbot, user=your_public_key
   - Behavior: send email when signal detected (dedupe per bar) and before confirm in executeTrade
*/

// ---- helpers UI / log ----
const $ = id => document.getElementById(id);
const logEl = $('log');
function log(...args){ const t=new Date().toLocaleTimeString(); const s=args.map(x=>typeof x==='object'?JSON.stringify(x):String(x)).join(' '); logEl.textContent=`[${t}] ${s}\n` + logEl.textContent; console.log(...args); }

// ---- chart ----
let chart=null, candleSeries=null, upSeries=null, lowSeries=null, midSeries=null;
function createChart(){
  const el = document.getElementById('chart');
  el.innerHTML='';
  chart = LightweightCharts.createChart(el, {
    layout:{ background:{color:'#07121a'}, textColor:'#dff0ff' },
    rightPriceScale:{ borderColor:'#0f2430' },
    timeScale:{ borderColor:'#0f2430' }
  });
  candleSeries = chart.addCandlestickSeries({ upColor:'#16a34a', downColor:'#ef4444', wickUpColor:'#16a34a', wickDownColor:'#ef4444' });
  upSeries = chart.addLineSeries({ color:'#60A5FA', lineWidth:1 });
  lowSeries = chart.addLineSeries({ color:'#60A5FA', lineWidth:1 });
  midSeries = chart.addLineSeries({ color:'#90cdf4', lineWidth:2 });
  window.addEventListener('resize', ()=> chart.applyOptions({ width: el.clientWidth }));
  log('Chart initialized');
}
createChart();

// ---- data fetch ----
const BINANCE_BASE = 'https://api.binance.com/api/v3';
const PAIR = 'CAKEUSDT';
function tfToBinance(tf){ return tf; }
async function fetchKlines(symbol, interval, limit=500){
  const url = `${BINANCE_BASE}/klines?symbol=${symbol}&interval=${tfToBinance(interval)}&limit=${limit}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Binance fetch failed: '+r.status);
  const j = await r.json();
  return j.map(k => ({ t:k[0], time: Math.floor(k[0]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5] }));
}

// ---- indicators: ATR + UT Bot (KV=1, ATR=10) ----
function trueRange(arr){
  const tr = new Array(arr.length).fill(NaN);
  for(let i=1;i<arr.length;i++){
    const a=arr[i], b=arr[i-1];
    tr[i] = Math.max(a.high - a.low, Math.abs(a.high - b.close), Math.abs(a.low - b.close));
  }
  return tr;
}
function computeATR(candles, period=10){
  const tr = trueRange(candles);
  const atr = new Array(candles.length).fill(NaN);
  if(tr.length <= period) return atr;
  let sum = 0;
  for(let i=1;i<=period;i++) sum += tr[i] || 0;
  atr[period] = sum/period;
  for(let i=period+1;i<tr.length;i++){
    atr[i] = ((atr[i-1] * (period-1)) + tr[i]) / period;
  }
  return atr;
}
function computeUT(candles){
  const atr = computeATR(candles, 10);
  const n = candles.length;
  const finalUpper = new Array(n).fill(NaN), finalLower = new Array(n).fill(NaN);
  const trend = new Array(n).fill(0), trail = new Array(n).fill(null);
  const signals = [];
  for(let i=0;i<n;i++){
    if(!isFinite(atr[i])) continue;
    const hl2 = (candles[i].high + candles[i].low)/2;
    const up = hl2 + 1 * atr[i];  // KV = 1
    const low = hl2 - 1 * atr[i];
    if(i===0){ finalUpper[i]=up; finalLower[i]=low; trend[i]=1; trail[i]=(trend[i]===1)?low:up; continue; }
    finalUpper[i] = (up < finalUpper[i-1]) ? up : finalUpper[i-1];
    finalLower[i] = (low > finalLower[i-1]) ? low : finalLower[i-1];
    const prev = trend[i-1] || 1;
    if(candles[i].close > finalUpper[i-1]) trend[i] = 1;
    else if(candles[i].close < finalLower[i-1]) trend[i] = -1;
    else trend[i] = prev;
    trail[i] = (trend[i] === 1) ? finalLower[i] : finalUpper[i];
    if(trend[i] !== trend[i-1]){
      const type = trend[i] === 1 ? 'buy' : 'sell';
      signals.push({ index:i, type, time: candles[i].time, price: candles[i].close });
    }
  }
  return { atr, finalUpper, finalLower, trail, trend, signals };
}

// ---- render & signal handling ----
let candles = [];
let lastSignalBar = null; // dedupe per bar
let entryPrice = null;
function toSeriesArray(arr){
  return arr.map((v,i)=> isFinite(v)? { time: Math.floor(candles[i].time), value: v } : null).filter(Boolean);
}
async function renderAll(){
  if(!candleSeries) createChart();
  const cand = candles.map(c => ({ time: Math.floor(c.time), open:c.open, high:c.high, low:c.low, close:c.close }));
  candleSeries.setData(cand);

  const ut = computeUT(candles);
  // series data
  const upArr = [], lowArr = [], midArr = [];
  for(let i=0;i<candles.length;i++){
    if(isFinite(ut.finalUpper[i])) upArr.push({ time: Math.floor(candles[i].time), value: ut.finalUpper[i] });
    if(isFinite(ut.finalLower[i])) lowArr.push({ time: Math.floor(candles[i].time), value: ut.finalLower[i] });
    if(isFinite(ut.trail[i])) midArr.push({ time: Math.floor(candles[i].time), value: ut.trail[i] });
  }
  upSeries.setData(upArr); lowSeries.setData(lowArr); midSeries.setData(midArr);

  // markers
  const markers = ut.signals.map(s => {
    const t = Math.floor(candles[s.index].time);
    return {
      time: t,
      position: s.type==='buy'? 'belowBar' : 'aboveBar',
      color: s.type==='buy'? '#16a34a' : '#ef4444',
      shape: s.type==='buy'? 'arrowUp' : 'arrowDown',
      text: `${s.type.toUpperCase()} ${s.price.toFixed(6)}`
    };
  });
  try{ candleSeries.setMarkers(markers); }catch(e){ console.warn('setMarkers err', e); }

  // newest signal handling
  if(ut.signals.length){
    const last = ut.signals[ut.signals.length-1];
    const barTime = last.time;
    const dedupe = true; // single latest signal per bar
    if(!dedupe || lastSignalBar !== barTime){
      // minGap filter
      const minGapPct = Math.max(0, Number($('minGap').value) || 1) / 100;
      let allow = true;
      if(entryPrice !== null){
        const diff = Math.abs((last.price - entryPrice) / entryPrice);
        if(diff < minGapPct){ allow = false; log(`Ignored ${last.type.toUpperCase()} (gap ${(diff*100).toFixed(3)}% < ${minGapPct*100}%)`); }
      }
      if(allow){
        lastSignalBar = barTime;
        log(`Signal detected: ${last.type.toUpperCase()} @ ${last.price} (bar ${new Date(barTime*1000).toLocaleString()})`);
        // send email immediately (payload matches template)
        await sendEmailPayload(last.type.toUpperCase(), 'CAKE/USDT', last.price, candles[last.index].volume || 0, `${last.price} est`);
      }
    }
  }
}

// ---- EmailJS helpers ----
function loadEmailCfg(){
  try{
    const raw = localStorage.getItem('ut_email_cfg_final');
    if(!raw) return;
    const cfg = JSON.parse(raw);
    $('emailService').value = cfg.service||'';
    $('emailTemplate').value = cfg.template||'';
    $('emailUser').value = cfg.user||'';
    if(cfg.user && window.emailjs && emailjs.init) emailjs.init(cfg.user);
    updateEmailUI();
    log('Email config loaded');
  }catch(e){ log('loadEmailCfg err', e.message); }
}
function saveEmailCfg(){
  const cfg = { service: $('emailService').value.trim(), template: $('emailTemplate').value.trim(), user: $('emailUser').value.trim() };
  localStorage.setItem('ut_email_cfg_final', JSON.stringify(cfg));
  try{ if(cfg.user && window.emailjs && emailjs.init) emailjs.init(cfg.user); }catch(e){}
  updateEmailUI();
  log('Email config saved');
}
function updateEmailUI(){ $('btnTestEmail').disabled = !($('emailService').value && $('emailTemplate').value && $('emailUser').value); }

async function sendEmailPayload(signalType, pair, price, volume, estimation){
  const svc = $('emailService').value.trim(), tmpl = $('emailTemplate').value.trim(), user = $('emailUser').value.trim();
  if(!svc || !tmpl || !user){
    log('(email) skipped — not configured');
    return;
  }
  try{
    emailjs.init(user);
    const payload = {
      signalType: signalType,
      signalClass: signalType==='BUY' ? '' : 'sell',
      pair: pair,
      price: String(Number(price)),
      volume: String(volume),
      estimation: String(estimation),
      time: new Date().toLocaleString()
    };
    const res = await emailjs.send(svc, tmpl, payload);
    log(`Email sent: ${signalType} (${res.status||''})`);
    return res;
  }catch(e){ log('sendEmailPayload error: '+(e.text||e.message||e)); }
}

// ---- polling lifecycle ----
let pollHandle = null;
async function start(tf){
  stop();
  try{
    const limit = Number($('limit').value) || 600;
    candles = await fetchKlines(PAIR, tf, limit);
    await renderAll();
    log(`Loaded ${candles.length} candles for ${PAIR} ${tf}`);
  }catch(e){ log('Initial load error: '+(e.message||e)); }
  // polling interval
  const override = Number($('pollSec').value) || 0;
  const defaultMs = { '1m':10000, '5m':30000, '15m':60000, '1h':180000 };
  const ms = override > 0 ? (override*1000) : (defaultMs[tf] || 30000);
  pollHandle = setInterval(async ()=>{
    try{
      const latestArr = await fetchKlines(PAIR, tf, 2);
      const latest = latestArr[latestArr.length-1];
      if(!latest) return;
      const keep = Number($('limit').value) || 600;
      if(candles.length && candles[candles.length-1].t === latest.t){
        candles[candles.length-1] = latest;
      } else {
        candles = [...candles, latest].slice(-keep);
      }
      await renderAll();
    }catch(e){ log('Poll error: '+(e.message||e)); }
  }, ms);
  log('Polling started every ' + (ms/1000) + 's');
}
function stop(){ if(pollHandle){ clearInterval(pollHandle); pollHandle = null; log('Polling stopped'); } }

// ---- executeTrade: send email BEFORE confirm ----
// NOTE: this is a simplified wrapper that will ask for CONFIRM prompt but sends email first.
// For safety, this function only simulates if in paper mode (keeps original behavior).
async function executeTrade(direction, opts={force:false}){
  try{
    const priceNow = candles[candles.length-1].close;
    // send email BEFORE confirmation
    await sendEmailPayload(direction.toUpperCase(), 'CAKE/USDT', priceNow, 0, 'est');
    // then confirm with user
    const ok = prompt(`CONFIRM ${direction.toUpperCase()} at ${priceNow}?\nType CONFIRM to proceed.`,'');
    if(ok !== 'CONFIRM'){ log(`${direction.toUpperCase()} cancelled by user`); return; }
    if($('minGap')){ // simulate integration: set entryPrice on buy
      if(direction === 'buy'){ entryPrice = priceNow; log('Entry price set (simulated):', entryPrice); }
      if(direction === 'sell'){ entryPrice = null; log('Entry cleared (simulated sell)'); }
    }
    log(`${direction.toUpperCase()} executed (simulated).`);
  }catch(e){ log('executeTrade error: '+(e.message||e)); }
}

// ---- UI wiring ----
$('btnLoad').addEventListener('click', ()=> start($('tfSelect').value));
$('btnSaveEmail').addEventListener('click', saveEmailCfg);
$('btnTestEmail').addEventListener('click', async ()=>{
  try{
    const svc = $('emailService').value.trim(), tmpl = $('emailTemplate').value.trim(), user = $('emailUser').value.trim();
    if(!svc||!tmpl||!user){ alert('Isi service & template & user'); return; }
    emailjs.init(user);
    await emailjs.send(svc, tmpl, { signalType:'TEST', signalClass:'', pair:PAIR, price:'0', volume:'0', estimation:'0', time:new Date().toLocaleString() });
    alert('Test email sent — cek inbox');
  }catch(e){ alert('Test failed: '+(e && (e.text||e.message) || e)); log('test email err', e); }
});
$('emailService').addEventListener('input', ()=> updateEmailUI());
$('emailTemplate').addEventListener('input', ()=> updateEmailUI());
$('emailUser').addEventListener('input', ()=> updateEmailUI());

loadEmailCfg();
start($('tfSelect').value);

// expose minimal debug
window._ut_final = { start, stop, executeTrade, sendEmailPayload };

</script>
</body>
</html>
