<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UT-Bot Markers — Lightweight Charts + Binance</title>

<!-- Lightweight Charts -->
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

<style>
  :root{--bg:#07121a;--card:#0b1820;--muted:#9fb4c9;--accent:#06b6d4}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6f6ff}
  .wrap{max-width:1100px;margin:12px auto;padding:12px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0;font-size:16px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
  input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#071927;color:#eaf6ff}
  button{cursor:pointer;background:var(--accent);color:#042a2f;border:0}
  #chartContainer{height:560px;border-radius:8px;overflow:hidden;background:#07121a;margin-top:12px}
  .log{margin-top:12px;background:#06121a;padding:10px;border-radius:8px;font-family:monospace;height:160px;overflow:auto;font-size:13px}
  .small{color:var(--muted);font-size:13px}
  label{font-size:13px;color:var(--muted);margin-right:6px}
  @media(max-width:800px){#chartContainer{height:420px}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>UT-Bot Markers — Binance (Lightweight Chart)</h1>
      <div class="small">Marker BUY / SELL akan muncul berdasarkan UT-Bot ATR trailing flip</div>
    </div>
    <div class="small" id="status">Idle</div>
  </header>

  <div class="controls">
    <label>Symbol</label>
    <input id="symbol" value="CAKEUSDT" style="width:140px" />
    <label>Interval</label>
    <select id="interval">
      <option value="1m">1m</option>
      <option value="5m" selected>5m</option>
      <option value="15m">15m</option>
      <option value="1h">1h</option>
      <option value="4h">4h</option>
      <option value="1d">1d</option>
    </select>
    <label>Candles</label>
    <input id="limit" type="number" value="500" min="50" max="1000" style="width:90px" />
    <label>ATR len</label>
    <input id="atrLen" type="number" value="14" min="2" style="width:80px" />
    <label>Mult</label>
    <input id="mult" type="number" step="0.1" value="3" style="width:80px" />
    <button id="btnLoad">Load</button>
    <button id="btnStart">Start</button>
    <button id="btnStop" disabled>Stop</button>
  </div>

  <div id="chartContainer"></div>

  <div class="log" id="log"></div>
</div>

<script>
(function(){
  const $ = id => document.getElementById(id);
  const logEl = $('log');
  function log(msg, obj){
    const t = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = `[${t}] ${msg}` + (obj ? ' ' + JSON.stringify(obj) : '');
    logEl.prepend(line);
    while(logEl.childNodes.length > 400) logEl.removeChild(logEl.lastChild);
    console.log(msg, obj || '');
  }
  function setStatus(s){ $('status').textContent = s; }

  // Chart
  const container = $('chartContainer');
  let chart = null;
  let candleSeries = null;
  function createChart(){
    container.innerHTML = '';
    chart = LightweightCharts.createChart(container, {
      layout: { backgroundColor: '#07121a', textColor: '#e6eef7' },
      grid: { vertLines: { color: 'rgba(255,255,255,0.02)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
      rightPriceScale: { borderColor: 'rgba(255,255,255,0.06)' },
      timeScale: { borderColor: 'rgba(255,255,255,0.06)' }
    });
    candleSeries = chart.addCandlestickSeries({
      upColor: '#26a69a', downColor: '#ef5350', wickUpColor: '#26a69a', wickDownColor: '#ef5350', borderVisible: false
    });
    window.addEventListener('resize', ()=> chart.applyOptions({ width: container.clientWidth }));
  }

  // Fetch klines from Binance
  async function fetchKlines(symbol, interval, limit=500){
    symbol = symbol.toUpperCase();
    const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}`;
    log('Fetching klines', {symbol, interval, limit});
    const resp = await fetch(url);
    if(resp.status === 429) throw new Error('Binance rate limited (429). Reduce limit or add delay.');
    if(!resp.ok) {
      const t = await resp.text();
      throw new Error('Klines fetch failed: ' + resp.status + ' ' + t);
    }
    const data = await resp.json();
    return data.map(d => ({
      time: Math.floor(d[0]/1000),
      open: Number(d[1]), high: Number(d[2]), low: Number(d[3]), close: Number(d[4]), volume: Number(d[5])
    }));
  }

  // Indicator helpers: TR and ATR (Wilder / RMA)
  function trueRange(c){
    const tr = new Array(c.length).fill(NaN);
    for(let i=1;i<c.length;i++){
      const a=c[i], b=c[i-1];
      tr[i] = Math.max(a.high - a.low, Math.abs(a.high - b.close), Math.abs(a.low - b.close));
    }
    return tr;
  }
  function computeATR(candles, period){
    const tr = trueRange(candles);
    const atr = new Array(candles.length).fill(NaN);
    let sum = 0;
    for(let i=1;i<=period && i<tr.length; i++) sum += tr[i] || 0;
    if(tr.length <= period) return atr;
    atr[period] = sum / period;
    for(let i=period+1;i<tr.length;i++){
      atr[i] = ((atr[i-1] * (period - 1)) + tr[i]) / period;
    }
    return atr;
  }

  // UT-like trailing bands + flip detection
  function computeUTSignals(candles, atrLen=14, mult=3){
    const n = candles.length;
    const atr = computeATR(candles, atrLen);
    const upper = new Array(n).fill(NaN), lower = new Array(n).fill(NaN), finalUpper = new Array(n).fill(NaN), finalLower = new Array(n).fill(NaN);
    const trend = new Array(n).fill(0), signals = new Array(n).fill(null);

    for(let i=0;i<n;i++){
      if(!isFinite(atr[i])) continue;
      const hl2 = (candles[i].high + candles[i].low) / 2;
      upper[i] = hl2 + mult * atr[i];
      lower[i] = hl2 - mult * atr[i];
      if(i === 0){
        finalUpper[i] = upper[i];
        finalLower[i] = lower[i];
        trend[i] = 1;
        continue;
      }
      // adjust final bands
      finalUpper[i] = (upper[i] < finalUpper[i-1]) ? upper[i] : finalUpper[i-1];
      finalLower[i] = (lower[i] > finalLower[i-1]) ? lower[i] : finalLower[i-1];

      // determine trend using previous final bands
      let prev = trend[i-1] || 1;
      if(candles[i].close > finalUpper[i-1]) trend[i] = 1;
      else if(candles[i].close < finalLower[i-1]) trend[i] = -1;
      else trend[i] = prev;

      // detect flip
      if(trend[i] !== (trend[i-1] || prev)){
        signals[i] = trend[i] === 1 ? 'BUY' : 'SELL';
      }
    }

    return { atr, finalUpper, finalLower, trend, signals };
  }

  // draw markers based on signals
  function drawMarkers(candles, signals){
    const markers = [];
    for(let i=0;i<signals.length;i++){
      const s = signals[i];
      if(!s) continue;
      markers.push({
        time: candles[i].time,
        position: s === 'BUY' ? 'belowBar' : 'aboveBar',
        color: s === 'BUY' ? '#00d28a' : '#ff6b6b',
        shape: s === 'BUY' ? 'arrowUp' : 'arrowDown',
        text: s
      });
    }
    candleSeries.setMarkers(markers);
  }

  // main flow: load and render once
  let lastAlertKey = null;
  async function loadAndRender(){
    try{
      setStatus('Loading...');
      const symbol = $('symbol').value.trim().toUpperCase() || 'CAKEUSDT';
      const interval = $('interval').value;
      const limit = Math.max(50, Math.min(1000, Number($('limit').value) || 500));
      const atrLen = Math.max(2, Number($('atrLen').value) || 14);
      const mult = Math.max(0.1, Number($('mult').value) || 3);

      const candles = await fetchKlines(symbol, interval, limit);
      if(!chart) createChart();
      candleSeries.setData(candles);

      const ut = computeUTSignals(candles, atrLen, mult);
      drawMarkers(candles, ut.signals);

      log(`Rendered ${symbol} ${interval} (${candles.length} candles). Signals: ${ut.signals.filter(Boolean).length}`);
      setStatus(`Loaded ${symbol} ${interval} — signals: ${ut.signals.filter(Boolean).length}`);
    }catch(err){
      log('Load error: ' + (err.message || err));
      setStatus('Error: ' + (err.message || 'unknown'));
    }
  }

  // auto-polling
  let timer = null;
  function startAutoPoll(){
    if(timer) return;
    timer = setInterval(async ()=>{
      try{ await loadAndRender(); }catch(e){ log('Poll error: ' + (e.message||e)); }
    }, 30_000); // every 30s
    $('btnStart').disabled = true; $('btnStop').disabled = false;
    setStatus('Running (polling)');
  }
  function stopAutoPoll(){
    if(timer) clearInterval(timer); timer = null;
    $('btnStart').disabled = false; $('btnStop').disabled = true;
    setStatus('Stopped');
  }

  // events
  $('btnLoad').addEventListener('click', loadAndRender);
  $('btnStart').addEventListener('click', ()=>{
    loadAndRender().then(()=> startAutoPoll());
  });
  $('btnStop').addEventListener('click', stopAutoPoll);

  // init chart and initial load
  createChart();
  setTimeout(()=> { loadAndRender(); }, 200);

  // expose for debug
  window._utbot = { loadAndRender, computeUTSignals };

})();
</script>
</body>
</html>
