<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AutoBot CAKE/USDT â€” Fixed Exec + Email Alerts</title>
  <style>
    :root{--card:#fff;--bg:#fffaf2;--text:#1e1b16}
    body{font-family:Inter,ui-sans-serif,system-ui;background:linear-gradient(#fff7e6,#fff);color:var(--text);margin:0;padding:40px}
    .wrap{max-width:2600px;margin:0 auto}
    .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:12px;border:1px solid #eee}
    .row{display:grid;grid-template-columns:1.6fr 1fr;gap:22px}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:14px}
    button{padding:18px 22px;border-radius:20px;border:0;cursor:pointer}
    .btn-primary{background:#111;color:#fff}
    .btn-buy{background:#2563eb;color:#fff}
    .btn-sell{background:#f59e0b;color:#fff}
    .log{height:320px;overflow:auto;font-family:monospace;font-size:12px;background:#fafafa;padding:8px;border-radius:8px}
    #lwchart{height:1420px}
    .pill{background:#fff;padding:6px 10px;border-radius:999px;border:1px solid #e6e6e6}
  </style>

  <!-- Ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
  <!-- TradingView widget -->
  <script src="https://s3.tradingview.com/tv.js"></script>
  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
  <!-- EmailJS -->
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2>AutoBot â€” CAKE/USDT Â· Precision Reversal (fixed exec)</h2>
      <small>Mode: BUY di bawah LRC + RSI&lt;30 + UTBot buy. SELL di atas LRC + RSI&gt;70 + UTBot sell.</small>
    </div>

    <div class="row">
      <div>
        <div class="card">
          <div id="tvwrap" style="height:300px;border-radius:8px;overflow:hidden;margin-bottom:10px">
            <div id="tv_chart" style="height:100%;width:100%"></div>
          </div>

          <div id="lwchart" class="card"></div>


          <div class="card">
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <button id="btnConnect" class="btn-primary">Connect (MetaMask/Trust)</button>
              <span class="pill">Addr: <span id="addr">â€”</span></span>
              <button id="btnAuto" class="btn-primary">Start Auto</button>
              <button id="btnBuy" class="btn-buy">Manual BUY</button>
              <button id="btnSell" class="btn-sell">Manual SELL</button>
              <label class="pill"><input id="paper" type="checkbox" checked /> Paper mode</label>
            </div>

            <div class="controls" style="margin-top:12px">
              <div>
                <label>BASE (USDT)</label>
                <input id="base" value="0x55d398326f99059fF775485246999027B3197955" />
              </div>
              <div>
                <label>TOKEN (CAKE)</label>
                <input id="token" value="0x0E09FABB73BD3ADE0A17ECC321FD13A19E81CE82" />
              </div>
              <div>
                <label>Symbol (Binance)</label>
                <select id="symbol"><option value="CAKEUSDT" selected>CAKEUSDT</option></select>
              </div>
              <div>
                <label>Interval</label>
                <select id="interval"><option value="15m" selected>15m</option><option value="5m">5m</option><option value="1m">1m</option></select>
              </div>
              <div>
                <label>Bars keep</label>
                <input id="barsKeep" type="number" value="600" />
              </div>
              <div>
                <label>Slippage (e.g. 0.1)</label>
                <input id="slippage" value="0.1" />
              </div>
              <div>
                <label>UT ATR</label>
                <input id="utAtr" type="number" value="1" />
              </div>
              <div>
                <label>UT Factor</label>
                <input id="utFactor" type="number" value="10" />
              </div>
            </div>
          </div>

          <div class="card">
            <div class="log" id="logs"></div>
          </div>
        </div>
      </div>

      

<script>
(async () => {
  // use ethers v6 from window.ethers (UMD)
  // include formatUnits / parseUnits to avoid `undefined` errors
  const { BrowserProvider, JsonRpcProvider, Contract, getAddress, formatUnits, parseUnits } = window.ethers;

  // === EMAILJS CONFIG (ganti placeholder dengan milikmu) ===
   const EMAILJS_PUBLIC_KEY = "OGH12a8LlCboHPVz8";
  const EMAILJS_SERVICE_ID = "service_5hxo1hk";
  const EMAILJS_TEMPLATE_ID = "template_iq87egh";  
  // template expects: action, pair, price, mode, time, profit (profit optional)
  try { emailjs.init(EMAILJS_PUBLIC_KEY); log('EmailJS initialized'); } catch(e){ /* ignore init errors until replaced */ }

  async function sendEmailNotification(action, pair, price, mode, profitText=''){
    try{
      const timeStr = new Date().toLocaleString();
      const templateParams = {
        action: `[AUTO-BOT] ${action} Executed`,
        pair: pair,
        price: String(price),
        mode: mode,
        time: timeStr,
        profit: profitText
      };
      // only attempt send if EmailJS config replaced
      if (!EMAILJS_SERVICE_ID.includes('xxx') && !EMAILJS_TEMPLATE_ID.includes('xxx') && !EMAILJS_PUBLIC_KEY.includes('xxx')){
        const res = await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, templateParams);
        log(`Email sent: ${res.status} ${res.text || ''}`);
      } else {
        log('EmailJS placeholders still present â€” replace with your service/template/public key to enable email sending.');
        log(`(email preview) ${templateParams.action} | ${templateParams.pair} | ${templateParams.price} | ${templateParams.mode} | ${templateParams.time} ${profitText? '| Profit: '+profitText : ''}`);
      }
    }catch(err){ log('Email send error: '+(err.message||err)); }
  }

  // Pancake constants
  const PCS_V2_ROUTER = getAddress("0x10ED43C718714eb63d5aA57B78B54704E256024E");
  const DEFAULT_RPC = "https://bsc-dataseed.binance.org";
  const ROUTER_ABI = [
    "function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory amounts)",
    "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)",
    "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable returns (uint[] memory amounts)",
    "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory amounts)"
  ];
  const ERC20_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner, address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];

  // DOM helpers
  const $ = id => document.getElementById(id);
  const elAddr = $('addr'), elLogs = $('logs');
  const btnConnect = $('btnConnect'), btnAuto = $('btnAuto'), btnBuy = $('btnBuy'), btnSell = $('btnSell');
  const elBase = $('base'), elToken = $('token'), elPaper = $('paper'), elSlippage = $('slippage');
  const elSymbol = $('symbol'), elInterval = $('interval'), elBarsKeep = $('barsKeep');
  const elUtAtr = $('utAtr'), elUtFactor = $('utFactor');

  const readProvider = new JsonRpcProvider(DEFAULT_RPC);
  let walletProvider = null;
  let signer = null;
  let address = null;

  // lightweight charts (minimal)
  const lwc = LightweightCharts.createChart(document.getElementById('lwchart'), {
    layout:{ background:{ type: 'solid', color: '#ffffff' }, textColor:'#222' },
    rightPriceScale:{ borderVisible:false }, timeScale:{ borderVisible:false }, grid:{ vertLines:{ color:'#eee' }, horzLines:{ color:'#eee' } }
  });
  const candleSeries = lwc.addCandlestickSeries();
  const upperLine = lwc.addLineSeries({ lineWidth:1 });
  const lowerLine = lwc.addLineSeries({ lineWidth:1 });
  const midLine = lwc.addLineSeries({ lineWidth:2 });
  const trailLine = lwc.addLineSeries({ lineWidth:1, lineStyle:3 });

  let bars = [];
  let polling = null;
  let auto = false;
  let isHolding = false;
  let entryPrice = null;

  function log(msg){
    const time = new Date().toLocaleTimeString();
    elLogs.textContent = `[${time}] ${msg}
` + elLogs.textContent;
    console.log(`[LOG] ${msg}`);
  }

  const safeAddr = v=>{
    try{ return getAddress(String(v).trim()); }catch(e){ log('Invalid address: '+v); return null; }
  };

  // --- TA helpers (same as your original) ---
  function linearRegression(y){ const n=y.length; if(!n) return {slope:0,intercept:0}; let sx=0,sy=0,sxy=0,sxx=0; for(let i=0;i<n;i++){ const x=i+1; const v=y[i]; sx+=x; sy+=v; sxy+=x*v; sxx+=x*x;} const d=(n*sxx - sx*sx)||1e-12; const slope=(n*sxy - sx*sy)/d; const intercept=(sy - slope*sx)/n; return {slope,intercept}; }
  function stdev(vals){ const n=vals.length; if(!n) return 0; const m=vals.reduce((a,b)=>a+b,0)/n; const v=vals.reduce((acc,x)=>acc+(x-m)*(x-m),0)/n; return Math.sqrt(v); }
  function computeLRC_Open(bars, length=100, devUp=2, devDn=2){
    const opens = bars.map(b=>b.open); const n=opens.length;
    const mid=Array(n).fill(null), upper=Array(n).fill(null), lower=Array(n).fill(null);
    if(n<length) return {mid,upper,lower};
    for(let i=length-1;i<n;i++){
      const win=opens.slice(i-length+1,i+1);
      const {slope,intercept}=linearRegression(win);
      const xLast = length;
      const midVal = slope*xLast + intercept;
      const resid = win.map((v,idx)=>v - (slope*(idx+1) + intercept));
      const sd = stdev(resid);
      mid[i]=midVal; upper[i]=midVal + devUp*sd; lower[i]=midVal - devDn*sd;
    }
    return {mid,upper,lower};
  }
  function computeATR(ohlc, period=1){
    if(ohlc.length<2) return Array(ohlc.length).fill(null);
    const trs=[]; for(let i=1;i<ohlc.length;i++){ const h=ohlc[i].high, l=ohlc[i].low, pc=ohlc[i-1].close; trs.push(Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc))); }
    const atr=[]; let ema=null; const k=2/(period+1);
    for(let i=0;i<trs.length;i++){ if(i===0) ema=trs[0]; else ema=k*trs[i] + (1-k)*ema; atr.push(ema); }
    return [null, ...atr];
  }
  function computeUTBotSignals(ohlc, atrPeriod=1, factor=10){
    const atrArr = computeATR(ohlc, atrPeriod);
    const signals = new Array(ohlc.length).fill(null);
    const trail = new Array(ohlc.length).fill(null);
    if(ohlc.length===0) return {signals, trail};
    let trend = 0; let ts = null;
    for(let i=0;i<ohlc.length;i++){
      const c = ohlc[i].close; const atr = atrArr[i] ?? 0;
      const buyTs = c - factor*atr; const sellTs = c + factor*atr;
      if (i===0){ ts = buyTs; trail[i]=ts; trend=1; continue; }
      if (trend >= 0){
        ts = ts == null ? buyTs : Math.max(ts, buyTs); trail[i] = ts;
        if (c < ts){ trend = -1; signals[i] = 'sell'; ts = sellTs; trail[i]=ts; } else trend = 1;
      } else {
        ts = ts == null ? sellTs : Math.min(ts, sellTs); trail[i] = ts;
        if (c > ts){ trend = 1; signals[i] = 'buy'; ts = buyTs; trail[i]=ts; } else trend = -1;
      }
    }
    return {signals, trail};
  }
  function computeRSI(ohlc, period=14){
    if (ohlc.length <= period) return Array(ohlc.length).fill(null);
    const rsi = Array(ohlc.length).fill(null);
    let gains = 0, losses = 0;
    for (let i = 1; i <= period; i++){
      const diff = ohlc[i].close - ohlc[i-1].close;
      if (diff > 0) gains += diff; else losses += -diff;
    }
    let avgGain = gains / period, avgLoss = losses / period;
    rsi[period] = avgLoss === 0 ? 100 : 100 - 100/(1 + (avgGain/avgLoss));
    for (let i = period+1; i < ohlc.length; i++){
      const diff = ohlc[i].close - ohlc[i-1].close;
      const gain = diff > 0 ? diff : 0;
      const loss = diff < 0 ? -diff : 0;
      avgGain = (avgGain*(period-1) + gain)/period;
      avgLoss = (avgLoss*(period-1) + loss)/period;
      rsi[i] = avgLoss === 0 ? 100 : 100 - 100/(1 + (avgGain/avgLoss));
    }
    return rsi;
  }

  function toSeries(arr){
    return bars.map((b,i)=> arr[i]==null? null: { time: Math.floor(b.t/1000), value: arr[i] }).filter(Boolean);
  }

  // ----- Safe BigNumber helpers -----
  function bnToBigInt(bn){
    if (bn === null || bn === undefined) return 0n;
    try { return BigInt(bn.toString()); } catch(e){ return 0n; }
  }
  function bnToStringReadable(bn, decimals=18){
    if (bn === null || bn === undefined) return "0";
    try {
      if (typeof formatUnits === 'function') return formatUnits(bn, decimals);
      const asBigInt = BigInt(bn.toString());
      const pow = 10n ** BigInt(decimals);
      const whole = asBigInt / pow;
      const frac = String(asBigInt % pow).padStart(decimals, '0').replace(/0+$/,'');
      return frac ? `${whole}.${frac}` : `${whole}`;
    } catch(e){ return bn.toString(); }
  }

  // render
  function renderAll(){
    const cand = bars.map(b=>({ time: Math.floor(b.t/1000), open:b.open, high:b.high, low:b.low, close:b.close }));
    candleSeries.setData(cand);
    const lrc = computeLRC_Open(bars, 100, 2, 2);
    const ut = computeUTBotSignals(bars, Number(elUtAtr.value||1), Number(elUtFactor.value||10));
    upperLine.setData(toSeries(lrc.upper)); lowerLine.setData(toSeries(lrc.lower)); midLine.setData(toSeries(lrc.mid));
    trailLine.setData(toSeries(ut.trail));
    const markers = [];
    for (let i=0;i<bars.length;i++){
      if (!ut.signals[i]) continue;
      markers.push({ time: Math.floor(bars[i].t/1000), position: ut.signals[i]==='buy' ? 'belowBar' : 'aboveBar', color: ut.signals[i]==='buy' ? 'green' : 'red', shape: ut.signals[i]==='buy' ? 'arrowUp' : 'arrowDown', text: ut.signals[i].toUpperCase() });
    }
    candleSeries.setMarkers(markers);
  }

  // fetch klines
  const BINANCE_BASE = "https://api.binance.com/api/v3";
  const intervalMap = {"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h"};
  async function fetchInitial(symbol, interval, limit=600){
    const url = `${BINANCE_BASE}/klines?symbol=${symbol}&interval=${intervalMap[interval]||interval}&limit=${limit}`;
    const res = await fetch(url); const arr = await res.json();
    return arr.map(k=>({ t: k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4] }));
  }
  async function fetchLatest(symbol, interval){
    const url = `${BINANCE_BASE}/klines?symbol=${symbol}&interval=${intervalMap[interval]||interval}&limit=2`;
    const res = await fetch(url); const arr = await res.json();
    const k = arr[arr.length-1];
    return { t:k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4] };
  }

  async function startPolling(){
    if (polling) clearInterval(polling);
    const sym = elSymbol.value || "CAKEUSDT";
    const tf = elInterval.value || "15m";
    try {
      bars = await fetchInitial(sym, tf, Number(elBarsKeep.value||600));
      renderAll();
      await mountTradingViewOnce();
      log(`Loaded ${bars.length} bars for ${sym} ${tf}`);
    } catch(e){ log('Load error: '+(e.message||e)); }

    const ms = tf==="1m"?10000:tf==="5m"?30000:60000;
    polling = setInterval(async ()=>{
      try{
        const latest = await fetchLatest(sym, tf);
        const keep = Number(elBarsKeep.value||600);
        if (bars.length && bars[bars.length-1].t === latest.t) bars[bars.length-1] = latest;
        else bars = [...bars, latest].slice(-keep);
        renderAll();
        if (auto) await evaluateAndMaybeTrade();
      }catch(e){ log('Poll error: '+(e.message||e)); }
    }, ms);
  }

  // tradingview mount
  let _tvWidgetInited=false,_tvPrevSymbol=null,_tvPrevInterval=null;
  async function mountTradingViewOnce(){
    const tvSymbol = elSymbol.value || 'CAKEUSDT';
    const tvFull = `BINANCE:${tvSymbol}`;
    const iv = elInterval.value||'5m';
    const ivMap = {'1m':'1','5m':'5','15m':'15','30m':'30','1h':'60'};
    const tvInterval = ivMap[iv]||iv;
    if (_tvWidgetInited && _tvPrevSymbol===tvFull && _tvPrevInterval===tvInterval) return;
    _tvPrevSymbol=tvFull; _tvPrevInterval=tvInterval;
    const container = document.getElementById('tv_chart');
    container.innerHTML = '';
    let attempts=0;
    while(typeof window.TradingView==='undefined' && attempts<6){ await new Promise(r=>setTimeout(r,300)); attempts++; }
    if(typeof window.TradingView==='undefined'){ log('TradingView unavailable'); container.innerHTML='<div style="padding:12px;color:#a00">TradingView tidak tersedia</div>'; return; }
    try {
      new TradingView.widget({ autosize:true, symbol:tvFull, interval:tvInterval, timezone:"Etc/UTC", theme:"light", style:"1", locale:"id", container_id:"tv_chart" });
      _tvWidgetInited=true;
      log('TradingView mounted: '+tvFull+' @'+tvInterval);
    } catch(e){ log('TV init err: '+(e.message||e)); container.innerHTML='<div style="padding:12px;color:#a00">Gagal memuat TradingView</div>'; }
  }

  // decision logic (unchanged)
  function decide(){
    if (!bars.length) return null;
    const lrc = computeLRC_Open(bars, 100, 2, 2);
    const ut  = computeUTBotSignals(bars, Number(elUtAtr.value||1), Number(elUtFactor.value||10));
    const rsi = computeRSI(bars, 14);
    const i = bars.length-1;
    const sigUT = ut.signals[i];
    const price = bars[i].close;
    const lower = lrc.lower[i], upper = lrc.upper[i];
    const curRSI = rsi[i] ?? null;
    if (sigUT === 'buy' && lower!=null && price <= lower && curRSI !== null && curRSI < 30) return 'buy';
    if ((sigUT === 'sell') || (upper!=null && price >= upper && curRSI !== null && curRSI > 70)) return 'sell';
    return null;
  }

  // ---- on-chain helpers: corrected for ethers v6 usage + robust BigNumber handling ----
  function toBigInt(amount) {
    if (typeof amount === 'bigint') return amount;
    if (typeof amount === 'number') return BigInt(Math.floor(amount));
    if (typeof amount === 'string') {
      try { return BigInt(amount); } catch(e){ return BigInt(Number(amount)); }
    }
    return BigInt(0);
  }

  async function getDecimalsAndBalance(tokenAddr) {
    const erc = new Contract(tokenAddr, ERC20_ABI, readProvider);
    let decimals = 18;
    try { decimals = Number(await erc.decimals().catch(()=>18)); } catch(e){ log('decimals() failed, default 18'); }
    let balRaw = 0;
    try { balRaw = await erc.balanceOf(address).catch(()=>0); } catch(e){ log('balanceOf() failed, returning 0'); balRaw = 0; }
    const bal = bnToBigInt(balRaw);
    const readable = bnToStringReadable(balRaw, decimals);
    return { decimals, bal, readable, raw: balRaw };
  }

  async function ensureApproval(tokenAddr, spender, amountBig) {
    if (!signer) throw new Error('Signer not ready');
    const erc = new Contract(tokenAddr, ERC20_ABI, signer);
    let allowanceRaw = 0;
    try { allowanceRaw = await erc.allowance(address, spender).catch(()=>0); } catch(e){ log('allowance() failed, assume 0'); allowanceRaw = 0; }
    const allowance = bnToBigInt(allowanceRaw);
    log(`Allowance current: ${allowance}`);
    if (allowance < BigInt(amountBig)) {
      log('Approving router to spend token...');
      const tx = await erc.approve(spender, BigInt(amountBig));
      log('Approve tx sent: ' + tx.hash);
      await tx.wait();
      log('Approve confirmed');
    } else {
      log('Approval sufficient');
    }
  }

  function calcOutMinBig(amountOutBig, slipFloat){
    const bps = 10000n;
    const slipBps = BigInt(Math.floor((slipFloat||0)*10000));
    return (BigInt(amountOutBig) * (bps - slipBps)) / bps;
  }

  async function executeTrade(direction, opts={force:false}) {
    try {
      if (!signer) {
        const ok = await connectWallet();
        if (!ok) { log('Wallet not connected - abort'); return; }
      }
      const base = safeAddr(elBase.value);
      const token = safeAddr(elToken.value);
      if (!base || !token) { log('Invalid base/token'); return; }

      // paper mode
      if (elPaper.checked) {
        if (direction === 'buy') {
          const {decimals, bal} = await getDecimalsAndBalance(base);
          const amt = (bal * 100n) / 100n;
          if (amt === 0n) { log('[PAPER] BUY skipped â€” USDT 0'); return; }
          isHolding = true; entryPrice = bars[bars.length-1].close;
          log(`[PAPER] BUY simulated â€” amt=${amt} (dec ${decimals}) entry=${entryPrice}`);
          // send email only for auto (not manual)
          if (!opts.force) await sendEmailNotification('BUY', (elSymbol.value||'CAKEUSDT'), entryPrice, 'Auto');
          return;
        } else {
          const {decimals, bal} = await getDecimalsAndBalance(token);
          const amt = (bal * 100n) / 100n;
          if (amt === 0n) { log('[PAPER] SELL skipped â€” CAKE 0'); return; }
          // compute sell price and profit if entryPrice available
          const sellPrice = bars[bars.length-1].close;
          let profitText = '';
          if (entryPrice) {
            const pct = ((sellPrice - entryPrice) / entryPrice) * 100;
            profitText = (pct>=0?'+':'') + pct.toFixed(2) + '%';
          }
          isHolding = false; entryPrice = null;
          log(`[PAPER] SELL simulated â€” amt=${amt} (dec ${decimals})`);
          if (!opts.force) await sendEmailNotification('SELL', (elSymbol.value||'CAKEUSDT'), sellPrice, 'Auto', profitText);
          return;
        }
      }

      const router = new Contract(PCS_V2_ROUTER, ROUTER_ABI, signer);

      if (direction === 'buy' && isHolding && !opts.force) { log('BUY skipped â€” already holding'); return; }
      if (direction === 'sell' && !isHolding && !opts.force) { log('SELL skipped â€” not holding'); return; }

      if (direction === 'buy') {
        // buy path: BASE -> TOKEN
        const {decimals, bal} = await getDecimalsAndBalance(base);
        const amountIn = (bal * 100n) / 100n;
        if (amountIn === 0n) { log('BUY aborted â€” base balance zero'); return; }

        // estimate amounts out (read-only)
        log('Estimating amountsOut for buy...');
        const amountsOut = await router.getAmountsOut(amountIn, [base, token]).catch(e=>{ throw new Error('getAmountsOut failed: '+(e.message||e)); });
        const outRaw = amountsOut[amountsOut.length-1];
        const outBig = bnToBigInt(outRaw);
        const outDecimals = (await (new Contract(token, ERC20_ABI, readProvider)).decimals().catch(()=>18));
        const outMin = calcOutMinBig(outBig, Number(elSlippage.value||0.01));
        log(`Estimate out: ${bnToStringReadable(outRaw, outDecimals)} (${outBig}) | min after slip: ${bnToStringReadable(outMin, outDecimals)} (${outMin})`);

        // ask confirmation (show human-readable approximate amounts using decimals)
        const confirmMsg = `CONFIRM BUY?
Base token: ${base}
Token: ${token}
AmountBase (raw): ${amountIn}
EstimatedOut (raw): ${outBig}
Slippage: ${elSlippage.value}
Reply CONFIRM to proceed.`;
        const ok = prompt(confirmMsg,'');
        if (ok !== 'CONFIRM') { log('User cancelled BUY'); return; }

        // ensure approval of base to router
        await ensureApproval(base, PCS_V2_ROUTER, amountIn);

        // execute swap
        log('Sending swapExactTokensForTokens (BUY)...');
        const tx = await router.swapExactTokensForTokens(amountIn, outMin, [base, token], address, Math.floor(Date.now()/1000)+300);
        log('BUY tx sent: '+tx.hash);
        await tx.wait();
        log('BUY confirmed: '+tx.hash);
        isHolding = true;
        entryPrice = bars[bars.length-1].close;
        // send email only for auto trades (not manual forced)
        if (!opts.force) await sendEmailNotification('BUY', (elSymbol.value||'CAKEUSDT'), entryPrice, 'Auto');
      } else {
        // SELL: TOKEN -> BASE
        const {decimals, bal} = await getDecimalsAndBalance(token);
        const amountIn = bal;
        if (amountIn === 0n) { log('SELL aborted â€” token balance zero'); return; }

        log('Estimating amountsOut for sell...');
        const amountsOut = await router.getAmountsOut(amountIn, [token, base]).catch(e=>{ throw new Error('getAmountsOut failed: '+(e.message||e)); });
        const outRaw = amountsOut[amountsOut.length-1];
        const outBig = bnToBigInt(outRaw);
        const baseDecimals = (await (new Contract(base, ERC20_ABI, readProvider)).decimals().catch(()=>18));
        const outMin = calcOutMinBig(outBig, Number(elSlippage.value||0.1));
        log(`Estimate out: ${bnToStringReadable(outRaw, baseDecimals)} (${outBig}) | min after slip: ${bnToStringReadable(outMin, baseDecimals)} (${outMin})`);

        const confirmMsg = `CONFIRM SELL?
Token: ${token}
Base: ${base}
AmountToken (raw): ${amountIn}
EstimatedBase (raw): ${outBig}
Slippage: ${elSlippage.value}
Reply CONFIRM to proceed.`;
        const ok = prompt(confirmMsg,'');
        if (ok !== 'CONFIRM') { log('User cancelled SELL'); return; }

        await ensureApproval(token, PCS_V2_ROUTER, amountIn);

        log('Sending swapExactTokensForTokens (SELL)...');
        const tx = await router.swapExactTokensForTokens(amountIn, outMin, [token, base], address, Math.floor(Date.now()/1000)+300);
        log('SELL tx sent: '+tx.hash);
        await tx.wait();
        log('SELL confirmed: '+tx.hash);
        // compute profit if entryPrice present
        const sellPrice = bars[bars.length-1].close;
        let profitText = '';
        if (entryPrice) {
          const pct = ((sellPrice - entryPrice) / entryPrice) * 100;
          profitText = (pct>=0?'+':'') + pct.toFixed(2) + '%';
        }
        isHolding = false;
        entryPrice = null;
        // send email only for auto trades
        if (!opts.force) await sendEmailNotification('SELL', (elSymbol.value||'CAKEUSDT'), sellPrice, 'Auto', profitText);
      }
    } catch(err) {
      log('Trade error: ' + (err.reason || err.message || err));
      if (!opts._retry) {
        log('Retrying trade once...');
        await new Promise(r=>setTimeout(r,2000));
        return executeTrade(direction, {...opts, _retry:true});
      }
    }
  }

  async function evaluateAndMaybeTrade(){
    if (!auto) return;
    const d = decide();
    if (!d) return;
    if (d === 'buy' && isHolding) { log('Auto BUY skipped â€” holding'); return; }
    if (d === 'sell' && !isHolding) { log('Auto SELL skipped â€” not holding'); return; }
    log('Auto Signal: '+d.toUpperCase() + ' @ ' + bars[bars.length-1].close);
    await executeTrade(d);
  }

  // ðŸ”§ Hanya koneksi ke Trust Wallet
async function detectWalletProvider(){
  const any = window.ethereum;
  if (!any) return null;

  // Jika TrustWallet menyediakan multiple provider
  if (any.providers && Array.isArray(any.providers)){
    const trust = any.providers.find(p=>p.isTrust || p.isTrustWallet);
    if (trust) return new BrowserProvider(trust);
  }

  // Jika hanya satu provider tapi berasal dari Trust Wallet
  if (any.isTrust || any.isTrustWallet) {
    return new BrowserProvider(any);
  }

  // Jika bukan TrustWallet, tolak
  alert("âŒ Trust Wallet tidak terdeteksi. Silakan buka di dalam Trust Wallet browser.");
  return null;
}

async function connectWallet(){
  walletProvider = await detectWalletProvider();
  if (!walletProvider) { 
    log('Trust Wallet tidak ditemukan.');
    alert('Trust Wallet tidak terdeteksi di browser ini.');
    return false; 
  }
  try {
    await walletProvider.send('eth_requestAccounts', []);
    signer = await walletProvider.getSigner();
    address = await signer.getAddress();
    elAddr.textContent = address.slice(0,6)+'â€¦'+address.slice(-4);
    log('âœ… Trust Wallet connected: '+address);
    return true;
  } catch(e){ 
    log('Connect TrustWallet gagal: '+(e.message||e)); 
    return false; 
  }
}


  // manual UI bindings
  btnConnect.onclick = async ()=> await connectWallet();
  btnAuto.onclick = async ()=>{
    auto = !auto;
    btnAuto.textContent = auto? 'Stop Auto' : 'Start Auto';
    log('Auto: '+(auto?'ON':'OFF'));
    if (auto) await evaluateAndMaybeTrade();
  };
  btnBuy.onclick = async ()=>{ log('Manual BUY pressed'); await executeTrade('buy', {force:true}); };
  btnSell.onclick = async ()=>{ log('Manual SELL pressed'); await executeTrade('sell', {force:true}); };

  elSymbol.onchange = startPolling;
  elInterval.onchange = startPolling;

  // start
  startPolling();

  // small self-tests
  (function runTests(){
    log('Self-test: Fixed exec module loaded.');
  })();

})();
</script>
</body>
</html>
