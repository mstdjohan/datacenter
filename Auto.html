<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Autobot XRP/USDT — UT Bot (2,10) + Linear Regression Channel (100, 2, 2)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#0f1720; --text:#e5ecf4; --muted:#92a3b5; --accent:#38bdf8; --good:#22c55e; --bad:#ef4444; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;background:var(--bg);color:var(--text)}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;background:var(--panel);position:sticky;top:0;z-index:10;border-bottom:1px solid #1e293b}
    h1{font-size:18px;margin:0;font-weight:600}
    .wrap{display:grid;grid-template-columns: 320px 1fr; gap:12px; padding:12px}
    .card{background:var(--panel);border:1px solid #1e293b;border-radius:14px;padding:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input,select,button,textarea{background:#0b1220;color:var(--text);border:1px solid #1e293b;border-radius:10px;padding:8px 10px;font-size:13px}
    button{cursor:pointer}
    button.primary{background:var(--accent);color:#001018;border:none}
    .stat{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat .item{background:#0b1220;border:1px solid #1e293b;border-radius:12px;padding:10px}
    .stat .item b{display:block;font-size:16px;margin-bottom:2px}
    .green{color:var(--good)}
    .red{color:var(--bad)}
    #chart{height:520px}
    .log{height:220px;overflow:auto;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#0a0f18}
    .muted{color:var(--muted)}
    .badge{padding:3px 7px;border-radius:999px;border:1px solid #1e293b;background:#0b1220;font-size:11px}
    footer{padding:10px 14px;color:var(--muted);font-size:12px}
    @media(max-width:1000px){ .wrap{grid-template-columns:1fr} #chart{height:420px} }
  </style>
  <!-- TradingView Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <header>
    <h1>Autobot XRP/USDT — UT Bot (2,10) + Linear Regression Channel (100,2,2)</h1>
    <div class="row">
      <span class="badge" id="status">Idle</span>
      <button id="btnStart" class="primary">Start</button>
      <button id="btnStop">Stop</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="card">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <label>Exchange / Pair</label>
        <span class="badge">Binance • XRPUSDT</span>
      </div>

      <div class="row" style="margin-bottom:8px">
        <label for="interval">Timeframe</label>
        <select id="interval">
          <option value="1m">1m</option>
          <option value="3m">3m</option>
          <option value="5m" selected>5m</option>
          <option value="15m">15m</option>
          <option value="1h">1h</option>
        </select>
        <label for="limit">Candles</label>
        <select id="limit">
          <option>300</option>
          <option selected>500</option>
          <option>800</option>
          <option>1000</option>
        </select>
      </div>

      <h3 class="muted" style="margin:6px 0 6px">UT Bot (approx. Supertrend)</h3>
      <div class="row" style="margin-bottom:8px">
        <label>KV</label>
        <input id="kv" type="number" value="2" step="0.1" style="width:80px"/>
        <label>ATR Period</label>
        <input id="atr" type="number" value="10" step="1" style="width:80px"/>
      </div>

      <h3 class="muted" style="margin:6px 0 6px">Linear Regression Channel</h3>
      <div class="row" style="margin-bottom:8px">
        <label>Length</label>
        <input id="lrLen" type="number" value="100" step="1" style="width:80px"/>
        <label>Dev Up</label>
        <input id="devUp" type="number" value="2" step="0.1" style="width:80px"/>
        <label>Dev Down</label>
        <input id="devDn" type="number" value="2" step="0.1" style="width:80px"/>
      </div>

      <h3 class="muted" style="margin:6px 0 6px">Eksekusi</h3>
      <div class="row" style="margin-bottom:8px">
        <label>TP Min (%)</label>
        <input id="tpMin" type="number" value="2" step="0.1" style="width:80px"/>
        <label>Fee (%)</label>
        <input id="fee" type="number" value="0.1" step="0.01" style="width:80px"/>
      </div>
      <div class="row" style="margin-bottom:8px">
        <label>Modal USDT</label>
        <input id="capital" type="number" value="1000" step="10" style="width:120px"/>
        <button id="btnReset">Reset Modal</button>
      </div>

      <div class="stat" style="margin-top:10px">
        <div class="item"><label>Saldo USDT</label><b id="usdt">-</b></div>
        <div class="item"><label>Saldo XRP</label><b id="xrp">-</b></div>
        <div class="item"><label>PNL Realized</label><b id="pnlReal">-</b></div>
        <div class="item"><label>PNL Floating</label><b id="pnlFloat">-</b></div>
      </div>

      <div style="margin-top:10px" class="muted">Catatan: UT Bot di sini merupakan pendekatan ala Supertrend (KV, ATR). Sinyal bisa sedikit berbeda dari skrip Pine UT Bot Alerts Anda di TradingView karena perbedaan sumber data/aturan smoothing.</div>
    </aside>

    <main class="card">
      <div id="chart"></div>
      <div class="card" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <div><b>Live:</b> <span id="live"></span> • <span class="muted" id="lastUpdate"></span></div>
          <div><span class="badge" id="trendBadge">Trend: -</span></div>
        </div>
      </div>
      <div class="card log" id="log"></div>
    </main>
  </div>

  <footer>
    Mode bolak‑balik USDT ⇄ XRP: bot akan beli XRP saat sinyal BUY, dan jual kembali ke USDT saat SELL atau TP ≥ target. Interval update ±30 detik.
  </footer>

<script>
// ===== Utilities =====
const fmt = (n, d=4) => typeof n==='number' && isFinite(n) ? n.toFixed(d) : '-';
const nowStr = () => new Date().toLocaleString();
function log(msg){ const el=document.getElementById('log'); el.innerHTML = `[${nowStr()}] ${msg}<br>` + el.innerHTML; }
function setStatus(s){ document.getElementById('status').textContent=s; }

// ===== Data Fetch (Binance Klines) =====
async function getKlines(symbol='XRPUSDT', interval='5m', limit=500){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('Fetch klines gagal');
  const raw = await res.json();
  return raw.map(k=>({
    time: Math.floor(k[0]/1000), open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5]
  }));
}

// ===== Indicators =====
function ema(values, period){
  const k = 2/(period+1); let emaArr=[]; let prev;
  values.forEach((v,i)=>{ if(i===0){prev=v; emaArr.push(v);} else { prev = v*k + prev*(1-k); emaArr.push(prev);} });
  return emaArr;
}

function trueRange(candles){
  const tr=[NaN];
  for(let i=1;i<candles.length;i++){
    const c=candles[i], p=candles[i-1];
    const m1=c.high-c.low, m2=Math.abs(c.high-p.close), m3=Math.abs(c.low-p.close);
    tr.push(Math.max(m1,m2,m3));
  }
  return tr;
}

function atr(candles, period=10){
  const tr = trueRange(candles);
  let out = new Array(candles.length).fill(NaN);
  // Wilder's smoothing
  let sum=0; let i=1; // start from 1 because TR[0] is NaN
  while(i<=period && i<tr.length){ sum += tr[i]; i++; }
  if(i<=period) return out; // not enough
  out[period] = sum/period;
  for(let j=period+1;j<tr.length;j++){
    out[j] = (out[j-1]*(period-1) + tr[j]) / period;
  }
  return out;
}

// UT Bot approximation (Supertrend-like): returns {trend[+1/-1], upper, lower, line}
function utBot(candles, kv=2, atrPeriod=10){
  const n = candles.length; const res = {trend:new Array(n).fill(0), upper:new Array(n).fill(NaN), lower:new Array(n).fill(NaN), line:new Array(n).fill(NaN)};
  const atrArr = atr(candles, atrPeriod);
  let trend = 1; let upper=NaN, lower=NaN;
  for(let i=0;i<n;i++){
    const c = candles[i]; const hl2 = (c.high + c.low)/2; const nLoss = kv * atrArr[i];
    if(!isFinite(nLoss)){ res.trend[i]=0; continue; }
    const basicUpper = hl2 + nLoss; const basicLower = hl2 - nLoss; // (note: some UT variants invert; this fits Supertrend style)
    // Final upper/lower (carry forward)
    if(i===0){ upper = basicUpper; lower = basicLower; }
    else {
      const prev = candles[i-1];
      const prevUpper = res.upper[i-1];
      const prevLower = res.lower[i-1];
      upper = (basicUpper < prevUpper || prev === undefined || c.close > prevUpper) ? basicUpper : prevUpper;
      lower = (basicLower > prevLower || prev === undefined || c.close < prevLower) ? basicLower : prevLower;
    }
    // Determine trend & line
    const prevTrend = i>0 ? res.trend[i-1] : 1;
    trend = (c.close > upper) ? 1 : (c.close < lower ? -1 : prevTrend);
    const line = trend === 1 ? lower : upper;
    res.trend[i]=trend; res.upper[i]=upper; res.lower[i]=lower; res.line[i]=line;
  }
  return res;
}

// Linear Regression Channel for each bar (rolling)
function linRegChannel(candles, length=100, devUp=2, devDn=2){
  const n = candles.length; const mid=new Array(n).fill(NaN), up=new Array(n).fill(NaN), dn=new Array(n).fill(NaN);
  for(let i=length-1;i<n;i++){
    const slice = candles.slice(i-length+1, i+1);
    const closes = slice.map(c=>c.close);
    // least squares on x=0..len-1
    const m = closes.length; const x = [...Array(m).keys()];
    const sumX = x.reduce((a,b)=>a+b,0);
    const sumY = closes.reduce((a,b)=>a+b,0);
    const sumXX = x.reduce((a,b)=>a+b*b,0);
    const sumXY = x.reduce((a,xi,idx)=>a+xi*closes[idx],0);
    const denom = m*sumXX - sumX*sumX;
    const slope = denom!==0 ? (m*sumXY - sumX*sumY)/denom : 0;
    const intercept = (sumY - slope*sumX)/m;
    // value at last x (m-1)
    const yHat = intercept + slope*(m-1);
    // residual std
    const residuals = closes.map((y,i2)=> y - (intercept + slope*i2));
    const mean0 = 0; // residuals mean ~0
    const s2 = residuals.reduce((a,b)=>a+(b-mean0)*(b-mean0),0)/m;
    const stdev = Math.sqrt(s2);
    mid[i]=yHat; up[i]=yHat + devUp*stdev; dn[i]=yHat - devDn*stdev;
  }
  return {mid, up, dn};
}

// ===== Chart =====
const chart = LightweightCharts.createChart(document.getElementById('chart'), {
  layout:{ background:{type:'solid', color:'#0b0f14'}, textColor:'#cbd5e1' },
  grid:{ vertLines:{ color:'#1e293b' }, horzLines:{ color:'#1e293b' } },
  rightPriceScale:{ borderColor:'#1e293b' }, timeScale:{ borderColor:'#1e293b' },
  crosshair:{ mode:1 }
});
const candleSeries = chart.addCandlestickSeries();
const midSeries = chart.addLineSeries({ lineWidth:2 });
const upSeries = chart.addLineSeries({ lineWidth:1 });
const dnSeries = chart.addLineSeries({ lineWidth:1 });
const utLineSeries = chart.addLineSeries({ lineWidth:2 });
let markers=[];

// ===== Portfolio / Engine =====
const state = {
  running:false,
  symbol:'XRPUSDT',
  interval:'5m',
  limit:500,
  kv:2, atr:10, lrLen:100, devUp:2, devDn:2,
  tpMinPct:2, feePct:0.1,
  usdt:1000, xrp:0, pnlReal:0,
  lastSignal:null, position:null, // {side:'LONG', entry, size}
  timer:null,
};

function syncInputs(){
  state.interval = document.getElementById('interval').value;
  state.limit = +document.getElementById('limit').value;
  state.kv = +document.getElementById('kv').value; state.atr = +document.getElementById('atr').value;
  state.lrLen = +document.getElementById('lrLen').value; state.devUp = +document.getElementById('devUp').value; state.devDn = +document.getElementById('devDn').value;
  state.tpMinPct = +document.getElementById('tpMin').value; state.feePct = +document.getElementById('fee').value;
}

function refreshStats(livePrice){
  document.getElementById('usdt').textContent = fmt(state.usdt,2);
  document.getElementById('xrp').textContent = fmt(state.xrp,2);
  document.getElementById('pnlReal').textContent = fmt(state.pnlReal,2);
  const float = state.xrp>0 && livePrice ? (state.xrp*livePrice) - (state.position? state.position.entry*state.xrp : 0) : 0;
  document.getElementById('pnlFloat').textContent = fmt(float,2);
}

function fee(amount){ return amount * (state.feePct/100); }

function buyAll(price){
  if(state.usdt<=0) return false;
  const spend = state.usdt; const qty = (spend - fee(spend)) / price;
  state.usdt = 0; state.xrp += qty; state.position = {side:'LONG', entry:price, size:qty};
  log(`BUY XRP qty ${fmt(qty,2)} @ ${fmt(price,4)}`);
  markers.push({ time: Math.floor(Date.now()/1000), position: 'belowBar', shape: 'arrowUp', text: 'BUY', size:2 });
  candleSeries.setMarkers(markers);
  return true;
}

function sellAll(price){
  if(state.xrp<=0) return false;
  const qty = state.xrp; const gross = qty*price; const net = gross - fee(gross);
  const profit = net - (state.position? state.position.entry*qty:0);
  state.usdt += net; state.xrp = 0; state.pnlReal += profit; state.position=null;
  log(`SELL XRP qty ${fmt(qty,2)} @ ${fmt(price,4)} | P&L ${fmt(profit,2)} USDT`);
  markers.push({ time: Math.floor(Date.now()/1000), position: 'aboveBar', shape: 'arrowDown', text: 'SELL', size:2 });
  candleSeries.setMarkers(markers);
  return true;
}

function trendLabel(v){ return v>0? 'UP' : v<0? 'DOWN' : '-'; }

async function step(){
  try{
    syncInputs();
    const candles = await getKlines(state.symbol, state.interval, state.limit);
    candleSeries.setData(candles.map(c=>({ time:c.time, open:c.open, high:c.high, low:c.low, close:c.close })));

    const ut = utBot(candles, state.kv, state.atr);
    const lr = linRegChannel(candles, state.lrLen, state.devUp, state.devDn);

    const toLine = (arr) => arr.map((v,i)=> (isFinite(v)? {time:candles[i].time, value:v} : null)).filter(Boolean);
    midSeries.setData(toLine(lr.mid)); upSeries.setData(toLine(lr.up)); dnSeries.setData(toLine(lr.dn));
    utLineSeries.setData(toLine(ut.line));

    const last = candles[candles.length-1];
    const lastTrend = ut.trend[ut.trend.length-1];
    document.getElementById('live').textContent = `${fmt(last.close,6)} USDT`;    
    document.getElementById('lastUpdate').textContent = `TF ${state.interval} • ${new Date(last.time*1000).toLocaleString()}`;
    document.getElementById('trendBadge').textContent = `Trend: ${trendLabel(lastTrend)}`;

    // ====== SIGNAL ENGINE ======
    if(state.running){
      const entry = state.position?.entry ?? null;
      const tpMin = entry? entry * (1 + state.tpMinPct/100) : null;
      const lb = lr.dn[lr.dn.length-1]; const ub = lr.up[lr.up.length-1];

      // Rules:
      // 1) Open LONG when UT flips to UP and we're flat
      // 2) Close position when UT flips to DOWN, or TP >= min, or close < lower band (protective)
      if(!state.position && lastTrend===1){
        buyAll(last.close);
      } else if(state.position){
        const takeProfitHit = tpMin && last.close >= tpMin;
        const utSell = lastTrend===-1;
        const breakLower = isFinite(lb) && last.close < lb;
        if(utSell || takeProfitHit || breakLower){
          sellAll(last.close);
        }
      }
    }

    refreshStats(last.close);
  } catch(err){
    log(`Error: ${err.message}`);
  }
}

function start(){ if(state.running) return; state.running=true; setStatus('Running'); log('Bot started'); step(); state.timer = setInterval(step, 30000); }
function stop(){ state.running=false; setStatus('Stopped'); if(state.timer){ clearInterval(state.timer); state.timer=null; } log('Bot stopped'); }

// ===== Wire UI =====
btnStart.onclick = start;
btnStop.onclick = stop;

document.getElementById('btnReset').onclick = ()=>{
  syncInputs();
  state.usdt = +document.getElementById('capital').value; state.xrp=0; state.pnlReal=0; state.position=null; markers=[]; candleSeries.setMarkers(markers);
  log('Modal direset'); refreshStats();
};

// Initial
(async()=>{ refreshStats(); await step(); })();
</script>
</body>
</html>
