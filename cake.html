<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CAKE/USDT — UT Bot + Linear Regression + Trailing + Email</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:18px auto;padding:12px}
    h1{font-size:18px;margin:0 0 8px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
    .card{background:#f8f9fb;padding:10px;border-radius:8px;box-shadow:0 1px 4px rgba(0,0,0,.06);flex:1}
    label{display:block;font-size:12px;margin-bottom:6px}
    input,select,button{padding:8px;border-radius:6px;border:1px solid #ccc;width:100%}
    #chartWrap{height:420px}
    pre{background:#0b1220;color:#dbe9ff;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <h1>CAKE/USDT — UT Bot (1,10) + Linear Regression Channel (100,2) + Trailing + Email</h1>

  <div class="row">
    <div class="card" style="flex-basis:320px;min-width:280px">
      <label>Interval data (Binance)</label>
      <select id="interval"><option value="1h">1h</option><option value="15m">15m</option><option value="4h">4h</option></select>
      <label style="margin-top:8px">Trailling stop (%)</label>
      <input id="trailingPct" type="number" step="0.01" value="1.0" />
      <label style="margin-top:8px">UT Bot params — factor, ATR period</label>
      <input id="utFactor" type="text" value="1" />
      <input id="utAtrPeriod" type="number" value="10" style="margin-top:6px" />
      <label style="margin-top:8px">Linear Regression — period, multiplier</label>
      <input id="lrPeriod" type="number" value="100" />
      <input id="lrMult" type="number" value="2" style="margin-top:6px" />
    </div>

    <div class="card" style="flex-basis:360px;min-width:300px">
      <label>EmailJS — (opsional) konfigurasi untuk kirim email otomatis</label>
      <input id="emailUser" placeholder="EmailJS user id (aPZx0R9oxUbIQkLEv)" />
      <input id="emailService" placeholder="service_id (service_d48312b)" style="margin-top:6px" />
      <input id="emailTemplate" placeholder="template_id (template_1ktk40q)" style="margin-top:6px" />
      <label style="margin-top:8px">To email (penerima)</label>
      <input id="emailTo" placeholder="miningduta5@gmail.com" />
      <label style="margin-top:8px">Pesan email (gunakan {{signal}}, {{price}}, {{pair}})</label>
      <input id="emailMsgBuy" placeholder="Buy message" value="BUY signal for {{pair}} at {{price}} (signal={{signal}})" />
      <input id="emailMsgSell" placeholder="Sell message" value="SELL signal for {{pair}} at {{price}} (signal={{signal}})" style="margin-top:6px" />
    </div>

    <div class="card" style="flex-basis:260px;min-width:240px">
      <label>Aksi</label>
      <button id="startBtn">Start</button>
      <button id="stopBtn" style="margin-top:6px">Stop</button>
      <label style="margin-top:10px">Status</label>
      <pre id="status">idle</pre>
      <label style="margin-top:6px">Last signal</label>
      <pre id="lastSignal">-</pre>
    </div>
  </div>

  <div id="chartWrap" class="card"><canvas id="chart"></canvas></div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2.6.4/dist/email.min.js"></script>

  <script>
    // --- Utility indicators ---
    function sma(values, period){
      const out=[]; for(let i=0;i<values.length;i++){ if(i+1<period) { out.push(null); continue } let sum=0; for(let j=0;j<period;j++) sum+=values[i-j]; out.push(sum/period) } return out }

    function atr(high, low, close, period){
      const tr=[]; for(let i=0;i<close.length;i++){ if(i===0) tr.push(high[i]-low[i]); else tr.push(Math.max(high[i]-low[i], Math.abs(high[i]-close[i-1]), Math.abs(low[i]-close[i-1])))}
      const out=[]; let sum=0; for(let i=0;i<tr.length;i++){ if(i<period){ sum+=tr[i]; if(i===period-1) out.push(sum/period); else out.push(null) } else { sum = sum - tr[i-period] + tr[i]; out.push(sum/period) } } return out }

    function linearRegression(values){ // returns {slope, intercept}
      const n=values.length; let sumx=0,sumy=0,sumxy=0,sumxx=0; for(let i=0;i<n;i++){ sumx+=i; sumy+=values[i]; sumxy+=i*values[i]; sumxx+=i*i } const slope = (n*sumxy - sumx*sumy) / (n*sumxx - sumx*sumx); const intercept = (sumy - slope*sumx)/n; return {slope, intercept} }

    function lrChannel(close, period, mult){
      const mid=[]; const upper=[]; const lower=[];
      for(let i=0;i<close.length;i++){
        if(i+1<period){ mid.push(null); upper.push(null); lower.push(null); continue }
        const window = close.slice(i+1-period, i+1);
        const lr = linearRegression(window);
        const n=window.length; let sqsum=0; for(let j=0;j<n;j++){ const pred = lr.intercept + lr.slope*j; sqsum += Math.pow(window[j]-pred,2) }
        const std = Math.sqrt(sqsum/n);
        const midVal = lr.intercept + lr.slope*(n-1);
        mid.push(midVal); upper.push(midVal + mult*std); lower.push(midVal - mult*std);
      }
      return {mid,upper,lower}
    }

    // Simple UT Bot approximation: uses ATR-based trailing stop
    function utBot(close, high, low, atrPeriod, factor){
      const atrArr = atr(high, low, close, atrPeriod);
      const longStop = new Array(close.length).fill(null);
      const shortStop = new Array(close.length).fill(null);
      const trend = new Array(close.length).fill(null);
      for(let i=0;i<close.length;i++){
        if(atrArr[i]===null){ trend[i]=null; continue }
        const basicLong = (high[i] + low[i]) / 2 - factor * atrArr[i];
        const basicShort = (high[i] + low[i]) / 2 + factor * atrArr[i];
        if(i===0){ longStop[i]=basicLong; shortStop[i]=basicShort; trend[i]=1; continue }
        longStop[i] = Math.max(basicLong, longStop[i-1] || basicLong);
        shortStop[i] = Math.min(basicShort, shortStop[i-1] || basicShort);
        // determine trend
        if(close[i] > shortStop[i-1]) trend[i]=1; else if(close[i] < longStop[i-1]) trend[i]=-1; else trend[i]=trend[i-1] || 1;
      }
      return {atr:atrArr,longStop,shortStop,trend}
    }

    // --- Fetching Binance klines for CAKEUSDT ---
    async function fetchKlines(symbol, interval, limit=500){
      const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const r = await fetch(url);
      if(!r.ok) throw new Error('Binance fetch failed: '+r.status);
      const data = await r.json();
      // each kline: [ts, open, high, low, close, volume, ...]
      return data.map(k=>({
        t: k[0], open: +k[1], high:+k[2], low:+k[3], close:+k[4], vol:+k[5]
      }));
    }

    // --- Email sending via EmailJS ---
    function configureEmailJS(userId){ if(userId) emailjs.init(userId); }
    async function sendEmail(serviceId, templateId, toEmail, message){
      if(!serviceId || !templateId) { console.warn('EmailJS not configured'); return }
      const templateParams = { to_email: toEmail, message: message };
      try{
        const res = await emailjs.send(serviceId, templateId, templateParams);
        console.log('email sent', res);
      }catch(e){ console.error('email error', e) }
    }

    // --- Chart setup ---
    const ctx = document.getElementById('chart').getContext('2d');
    let chart = new Chart(ctx, { type:'line', data:{datasets:[]}, options:{scales:{x:{type:'time',time:{unit:'hour'}},y:{ticks:{maxTicksLimit:10}}},interaction:{mode:'index',intersect:false},plugins:{legend:{display:true}}}});

    // --- Main loop ---
    let intervalId = null;
    let lastProcessedTime = 0;
    let lastSignal = null;

    async function updateOnce(){
      try{
        const symbol = 'CAKEUSDT';
        const interval = document.getElementById('interval').value;
        const klines = await fetchKlines(symbol, interval, 500);
        const times = klines.map(k=>k.t);
        const close = klines.map(k=>k.close);
        const high = klines.map(k=>k.high);
        const low = klines.map(k=>k.low);

        // params
        const atrP = parseInt(document.getElementById('utAtrPeriod').value)||10;
        const factor = parseFloat(document.getElementById('utFactor').value)||1;
        const lrP = parseInt(document.getElementById('lrPeriod').value)||100;
        const lrM = parseFloat(document.getElementById('lrMult').value)||2;

        const ut = utBot(close,high,low,atrP,factor);
        const lr = lrChannel(close, lrP, lrM);

        // Build chart datasets
        const priceData = times.map((t,i)=>({x:new Date(t), y:close[i]}));
        const midData = lr.mid.map((v,i)=> v===null? null : {x:new Date(times[i]), y:v});
        const upperData = lr.upper.map((v,i)=> v===null? null : {x:new Date(times[i]), y:v});
        const lowerData = lr.lower.map((v,i)=> v===null? null : {x:new Date(times[i]), y:v});
        const shortStopData = ut.shortStop.map((v,i)=> v===null? null : {x:new Date(times[i]), y:v});
        const longStopData = ut.longStop.map((v,i)=> v===null? null : {x:new Date(times[i]), y:v});

        chart.data.datasets = [
          {label:'Close',data:priceData, borderWidth:1.5},
          {label:'LR Mid',data:midData,borderDash:[6,4],borderWidth:1,pointRadius:0},
          {label:'LR Upper',data:upperData,borderWidth:1,pointRadius:0},
          {label:'LR Lower',data:lowerData,borderWidth:1,pointRadius:0},
          {label:'UT LongStop',data:longStopData,borderWidth:1,pointRadius:0},
          {label:'UT ShortStop',data:shortStopData,borderWidth:1,pointRadius:0}
        ];
        chart.update();

        // Determine signals: when trend flips
        const trendArr = ut.trend;
        const latestIdx = trendArr.length-1;
        const prevIdx = latestIdx-1;
        if(prevIdx>=0 && trendArr[prevIdx] !== null && trendArr[latestIdx] !== null){
          if(trendArr[prevIdx] <= 0 && trendArr[latestIdx] > 0){ // flip to LONG -> BUY
            handleSignal('BUY', close[latestIdx], times[latestIdx]);
          } else if(trendArr[prevIdx] >= 0 && trendArr[latestIdx] < 0){ // flip to SHORT -> SELL
            handleSignal('SELL', close[latestIdx], times[latestIdx]);
          }
        }

      }catch(e){ console.error(e); document.getElementById('status').textContent = 'error: '+e.message }
    }

    // Trailing stop management and signaling
    const positions = { active:false, side:null, entryPrice:null, trailingPct:0 };
    function handleSignal(signal, price, ts){
      const trailingPct = parseFloat(document.getElementById('trailingPct').value)||0;
      const statusEl = document.getElementById('status');
      const lastSignalEl = document.getElementById('lastSignal');

      // If no active position, open on BUY or SELL
      if(!positions.active){
        positions.active = true; positions.side = signal; positions.entryPrice = price; positions.trailingPct = trailingPct/100;
        lastSignal = {type:signal,price,ts};
        lastSignalEl.textContent = `${signal} @ ${price} (${new Date(ts).toLocaleString()})`;
        statusEl.textContent = `Opened ${signal} @ ${price} with trailing ${trailingPct}%`;
        // send email
        const emailUser = document.getElementById('emailUser').value.trim();
        const svc = document.getElementById('emailService').value.trim();
        const tmpl = document.getElementById('emailTemplate').value.trim();
        const to = document.getElementById('emailTo').value.trim();
        configureEmailJS(emailUser || null);
        const msg = (signal==='BUY')? document.getElementById('emailMsgBuy').value : document.getElementById('emailMsgSell').value;
        const finalMsg = msg.replace('{{signal}}',signal).replace('{{price}}',price).replace('{{pair}}','CAKE/USDT');
        if(svc && tmpl && to) sendEmail(svc, tmpl, to, finalMsg);
      } else {
        // If active and opposite signal, close and open new
        if((positions.side==='BUY' && signal==='SELL') || (positions.side==='SELL' && signal==='BUY')){
          statusEl.textContent = `Closed ${positions.side} @ ${price} — opened ${signal}`;
          positions.side = signal; positions.entryPrice = price; positions.trailingPct = trailingPct/100;
          lastSignal = {type:signal,price,ts};
          lastSignalEl.textContent = `${signal} @ ${price} (${new Date(ts).toLocaleString()})`;
          // send email
          const emailUser = document.getElementById('emailUser').value.trim();
          const svc = document.getElementById('emailService').value.trim();
          const tmpl = document.getElementById('emailTemplate').value.trim();
          const to = document.getElementById('emailTo').value.trim();
          configureEmailJS(emailUser || null);
          const msg = (signal==='BUY')? document.getElementById('emailMsgBuy').value : document.getElementById('emailMsgSell').value;
          const finalMsg = msg.replace('{{signal}}',signal).replace('{{price}}',price).replace('{{pair}}','CAKE/USDT');
          if(svc && tmpl && to) sendEmail(svc, tmpl, to, finalMsg);
        } else {
          // same direction — update trailing stop: we check if price moved favorably, otherwise check if trailing stop hit
          const side = positions.side; const entry = positions.entryPrice; const trail = positions.trailingPct;
          if(side==='BUY'){
            const peak = Math.max(entry, price);
            const stopPrice = peak * (1 - trail);
            if(price <= stopPrice){ positions.active=false; document.getElementById('status').textContent = `Trailing stop hit. Closed BUY @ ${price}`; }
          } else if(side==='SELL'){
            const valley = Math.min(entry, price);
            const stopPrice = valley * (1 + trail);
            if(price >= stopPrice){ positions.active=false; document.getElementById('status').textContent = `Trailing stop hit. Closed SELL @ ${price}`; }
          }
        }
      }
    }

    // Controls
    document.getElementById('startBtn').addEventListener('click', ()=>{
      if(intervalId) return; updateOnce(); intervalId = setInterval(updateOnce, 60*1000); document.getElementById('status').textContent='running';
    });
    document.getElementById('stopBtn').addEventListener('click', ()=>{ if(intervalId) clearInterval(intervalId); intervalId=null; document.getElementById('status').textContent='stopped'; });

    // Auto-size canvas
    window.addEventListener('resize', ()=> chart.resize());

  </script>
</body>
</html>
