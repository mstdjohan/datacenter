<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRP↔USDT Auto Trader (BSC Mainnet) — Stable Fix</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:#071024;color:#e6eef8;margin:0;padding:20px}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:linear-gradient(180deg,#081428,#06101a);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);}    
    h1{margin:0 0 10px;font-size:20px}
    label{display:block;margin-top:10px;color:#9fb0d0;font-size:13px}
    input,select,button{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit}
    .row{display:flex;gap:12px}
    .col{flex:1}
    .small{font-size:13px;color:#99b3d6}
    pre{white-space:pre-wrap;word-break:break-word;background:transparent;padding:8px}
    .muted{color:#7f9ec8}
    .danger{color:#ffb4a2}
    @media(max-width:880px){.row{flex-direction:column}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>XRP ↔ USDT Auto Trader — Stable Fix</h1>
      <div class="small muted">Perbaikan: mencegah error <code>Cannot read properties of undefined (reading 'emit')</code> dengan memastikan provider diproxy/ dinormalisasi dan tidak dipanggil sebelum siap. Mode: Mainnet (real trades). Gunakan hati-hati.</div>

      <label>Mode</label>
      <select id="mode">
        <option value="buy">Buy (USDT → XRP)</option>
        <option value="sell">Sell (XRP → USDT)</option>
      </select>

      <label>Connect Wallet</label>
      <div class="row">
        <input id="address" placeholder="Belum terhubung" readonly />
        <div style="width:140px"><button id="btnConnect">Connect</button></div>
      </div>

      <label>Network</label>
      <div class="row">
        <input id="network" placeholder="—" readonly />
        <input id="balance" placeholder="—" readonly />
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <label>Auto-selected Tokens (BEP20 on BSC)</label>
      <div class="row">
        <div class="col"><input id="tokenFrom" readonly /></div>
        <div style="width:220px"><input id="decFrom" placeholder="decimals" readonly /></div>
      </div>
      <div class="row">
        <div class="col"><input id="tokenTo" readonly /></div>
        <div style="width:220px"><input id="decTo" placeholder="decimals" readonly /></div>
      </div>

      <label>Amount (amount of source token to trade)</label>
      <input id="amount" placeholder="contoh: 50 (USDT) atau 100 (XRP)" />

      <label>Targets (harga dalam unit tokenTo per 1 tokenFrom — USDT per XRP)</label>
      <div class="row">
        <div class="col"><input id="tp1" placeholder="TP1" /></div>
        <div class="col"><input id="tp2" placeholder="TP2 (optional)" /></div>
        <div class="col"><input id="tp3" placeholder="TP3 (optional)" /></div>
      </div>
      <label>Stop Loss (SL)</label>
      <input id="sl" placeholder="SL" />

      <label>Slippage tolerance (%)</label>
      <input id="slippage" placeholder="0.8" value="0.8" />

      <div class="row" style="margin-top:12px;">
        <button id="btnStart" disabled>Start Bot</button>
        <button id="btnStop" disabled>Stop Bot</button>
      </div>

      <div style="margin-top:12px">
        <div class="small muted">Status</div>
        <div id="status">idle</div>
        <label style="margin-top:8px">Logs</label>
        <pre id="log">— ready —</pre>
      </div>

      <div style="margin-top:14px;color:#ffd1a9;font-size:13px">
        <strong>PERINGATAN:</strong> Ini akan melakukan transaksi nyata di BSC Mainnet jika Anda menekan Start. Mulailah dengan nominal kecil dan uji terlebih dahulu. Saya tidak bertanggung jawab atas kehilangan dana.
      </div>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.12/dist/index.js"></script>

  <script>
    window.addEventListener('load', function(){
      // constants
      const BSC_CHAIN_ID = 56;
      const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
      const WBNB = '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';
      const USDT = '0x55d398326f99059fF775485246999027B3197955';
      const XRP_BEP20 = '0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE';

      // elements
      const el = id => document.getElementById(id);
      function safeLog(msg){ try{ el('log').textContent = new Date().toLocaleTimeString() + ' — ' + String(msg) + '\n' + el('log').textContent; }catch(e){ console.log(msg); } console.log(msg); }

      // state
      let provider = null; // raw provider
      let safeProvider = null; // normalized provider (guarantees event methods present)
      let web3Provider = null; // ethers provider
      let signer = null;
      let account = null;
      let botInterval = null;
      let pollInterval = null;

      // web3modal
      const providerOptions = {
        walletconnect: {
          package: window.WalletConnectProvider && window.WalletConnectProvider.default ? window.WalletConnectProvider.default : window.WalletConnectProvider,
          options: { rpc: { 56: 'https://bsc-dataseed.binance.org/' } }
        }
      };
      const Web3ModalCtor = window.Web3Modal && (window.Web3Modal.default || window.Web3Modal);
      const web3Modal = Web3ModalCtor ? new Web3ModalCtor({ cacheProvider:false, providerOptions }) : null;

      // Normalize provider: add no-op event methods and safe nested connector object to avoid 'emit' errors
      function normalizeProvider(p){
        if(!p) return p;
        try{
          // add top-level methods if missing
          if(typeof p.on !== 'function') p.on = function(){ /* noop */ };
          if(typeof p.removeListener !== 'function') p.removeListener = function(){ /* noop */ };
          if(typeof p.off !== 'function') p.off = function(){ /* noop */ };
          if(typeof p.once !== 'function') p.once = function(){ /* noop */ };
          if(typeof p.emit !== 'function') p.emit = function(){ /* noop */ };

          // Ensure connector object exists (some libs call provider.connector.emit)
          if(typeof p.connector === 'undefined' || p.connector === null){ p.connector = {}; }
          if(typeof p.connector.emit !== 'function') p.connector.emit = function(){ /* noop */ };
          if(typeof p.connector.on !== 'function') p.connector.on = function(){ /* noop */ };
          if(typeof p.connector.off !== 'function') p.connector.off = function(){ /* noop */ };

          // ensure wc / wcProvider fallback
          if(typeof p.wc === 'undefined' || p.wc === null){ p.wc = {}; }
          if(typeof p.wc.emit !== 'function') p.wc.emit = function(){ /* noop */ };

          return p;
        }catch(e){ safeLog('normalizeProvider failed: ' + e); return p; }
      }

      // set tokens according to mode
      function applyMode(){
        const mode = el('mode').value; // buy or sell
        if(mode === 'buy'){
          el('tokenFrom').value = USDT; el('tokenTo').value = XRP_BEP20;
        }else{
          el('tokenFrom').value = XRP_BEP20; el('tokenTo').value = USDT;
        }
        el('decFrom').value = '';
        el('decTo').value = '';
      }
      el('mode').addEventListener('change', applyMode);
      applyMode();

      // helper: read decimals safely (returns number or throws)
      async function readDecimals(tokenAddress){
        if(!web3Provider) throw new Error('provider not ready');
        if(!ethers.utils.isAddress(tokenAddress)) throw new Error('invalid token address');
        const erc = new ethers.Contract(tokenAddress, ['function decimals() view returns (uint8)'], web3Provider);
        const d = await erc.decimals();
        return Number(d);
      }

      // helper: price via getAmountsOut
      async function getPrice(tokenIn, tokenOut, amountInHuman){
        if(!web3Provider) throw new Error('provider not ready');
        const router = new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider);
        const decIn = await readDecimals(tokenIn); const decOut = await readDecimals(tokenOut);
        const amountIn = ethers.utils.parseUnits(String(amountInHuman), decIn);
        // try direct path
        try{ const amounts = await router.getAmountsOut(amountIn, [tokenIn, tokenOut]); return Number(ethers.utils.formatUnits(amounts[amounts.length-1], decOut)); }
        catch(e){ const amounts = await router.getAmountsOut(amountIn, [tokenIn, WBNB, tokenOut]); return Number(ethers.utils.formatUnits(amounts[amounts.length-1], decOut)); }
      }

      // approval
      async function approveIfNeeded(token, spender, amountHuman){
        if(!signer) throw new Error('signer not ready');
        const dec = await readDecimals(token);
        const erc = new ethers.Contract(token, ['function allowance(address owner, address spender) view returns (uint256)','function approve(address spender, uint256 amount) returns (bool)'], signer);
        const allowance = await erc.allowance(account, spender);
        const amount = ethers.utils.parseUnits(String(amountHuman), dec);
        if(allowance.gte(amount)) { safeLog('Allowance ok'); return true; }
        const tx = await erc.approve(spender, ethers.constants.MaxUint256);
        safeLog('Approve sent: ' + tx.hash);
        await tx.wait(); safeLog('Approve confirmed'); return true;
      }

      // swap
      async function swapExactTokens(tokenIn, tokenOut, amountInHuman, slippagePercent){
        if(!signer) throw new Error('signer not ready');
        const decIn = await readDecimals(tokenIn); const decOut = await readDecimals(tokenOut);
        const amountIn = ethers.utils.parseUnits(String(amountInHuman), decIn);
        // estimate out
        let amountsOut;
        try{ amountsOut = await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, [tokenIn, tokenOut]); }
        catch(e){ amountsOut = await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, [tokenIn, WBNB, tokenOut]); }
        const estOut = amountsOut[amountsOut.length-1];
        const amountOutMin = estOut.mul(10000 - Math.floor(slippagePercent*100)).div(10000);
        let path = [tokenIn, tokenOut];
        try{ await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, path); }
        catch(e){ path = [tokenIn, WBNB, tokenOut]; }
        const router = new ethers.Contract(PANCAKE_ROUTER, ['function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external'], signer);
        await approveIfNeeded(tokenIn, PANCAKE_ROUTER, amountInHuman);
        const deadline = Math.floor(Date.now()/1000) + 60*10;
        const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, amountOutMin, path, account, deadline, { gasLimit: 800000 });
        safeLog('Swap sent: ' + tx.hash);
        const receipt = await tx.wait(); safeLog('Swap confirmed: ' + receipt.transactionHash); return receipt;
      }

      // connect
      async function connect(){
        if(!web3Modal){ alert('Web3Modal tidak tersedia'); return; }
        try{
          provider = await web3Modal.connect().catch(() => null);
          // fallback to injected
          if(!provider && window.ethereum){ provider = window.ethereum; safeLog('Using window.ethereum fallback'); }
          if(!provider){ alert('Provider tidak ditemukan. Pastikan wallet mendukung WalletConnect atau MetaMask.'); return; }

          // Normalize provider to avoid emit/on undefined errors
          safeProvider = normalizeProvider(provider);

          web3Provider = new ethers.providers.Web3Provider(safeProvider, 'any');
          signer = web3Provider.getSigner();
          try{ account = await signer.getAddress(); }catch(e){ account = null; }
          if(account) el('address').value = account;

          const net = await web3Provider.getNetwork(); el('network').value = net.name + ' (' + net.chainId + ')';
          const bal = account ? await web3Provider.getBalance(account) : null; el('balance').value = bal ? ethers.utils.formatEther(bal) + ' BNB' : '—';

          if(Number(net.chainId) !== BSC_CHAIN_ID){ alert('Switch ke Binance Smart Chain (Mainnet) di wallet Anda. Bot tidak akan berjalan pada network lain.'); safeLog('Non-BSC network detected: ' + net.chainId); }

          // try fetch decimals for UI; if fail, keep Start disabled
          try{ const decF = await readDecimals(el('tokenFrom').value); el('decFrom').value = decF; const decT = await readDecimals(el('tokenTo').value); el('decTo').value = decT; el('btnStart').disabled = false; }catch(e){ safeLog('decimals failed: ' + e); el('btnStart').disabled = true; alert('Gagal membaca decimals token — kemungkinan token address salah atau token tidak ada di jaringan ini. Periksa token.'); }

          // Poll account/network periodically instead of relying on provider.emit
          if(pollInterval) clearInterval(pollInterval);
          pollInterval = setInterval(async ()=>{
            try{
              if(!web3Provider) return;
              const newNet = await web3Provider.getNetwork(); el('network').value = newNet.name + ' (' + newNet.chainId + ')';
              if(signer){ try{ const newAccount = await signer.getAddress(); if(newAccount && newAccount !== account){ account = newAccount; el('address').value = account; safeLog('account changed'); } }catch(e){}
                try{ const bal2 = account ? await web3Provider.getBalance(account) : null; el('balance').value = bal2 ? ethers.utils.formatEther(bal2) + ' BNB' : '—'; }catch(e){}
              }
            }catch(e){ /* ignore poll errors */ }
          }, 3500);

          el('btnStop').disabled = false;
          safeLog('Connected');
        }catch(e){ safeLog('connect error: ' + e); }
      }

      el('btnConnect').addEventListener('click', async ()=>{ if(!provider) await connect(); else { try{ if(provider && typeof provider.disconnect === 'function') await provider.disconnect(); }catch(e){} provider = null; safeProvider = null; web3Provider = null; signer = null; account = null; el('address').value=''; el('network').value=''; el('balance').value=''; el('btnStart').disabled=true; el('btnStop').disabled=true; if(pollInterval){ clearInterval(pollInterval); pollInterval=null; } safeLog('Disconnected'); } });

      // bot logic
      async function checkAndAct(){
        try{
          if(!web3Provider || !signer){ safeLog('Provider/signature not ready'); return; }
          const net = await web3Provider.getNetwork(); if(Number(net.chainId)!==BSC_CHAIN_ID){ safeLog('Not on BSC — skipping check'); return; }
          const tokenFrom = el('tokenFrom').value; const tokenTo = el('tokenTo').value; if(!ethers.utils.isAddress(tokenFrom) || !ethers.utils.isAddress(tokenTo)){ safeLog('Invalid token addresses'); return; }
          const amount = Number(el('amount').value); if(!amount || amount<=0){ safeLog('Invalid amount'); return; }

          let price;
          try{ price = await getPrice(tokenFrom, tokenTo, 1); }catch(e){ safeLog('getPrice error: ' + e); return; }
          safeLog('Market price (1 from → to): ' + price);

          const tp1 = Number(el('tp1').value) || null; const tp2 = Number(el('tp2').value) || null; const tp3 = Number(el('tp3').value) || null; const sl = Number(el('sl').value) || null; const slippage = Number(el('slippage').value) || 0.8;
          const mode = el('mode').value; // buy or sell

          if(mode === 'sell'){
            if(tp1 && price >= tp1){ safeLog('TP1 hit — selling'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp1').value=''; }
            else if(tp2 && price >= tp2){ safeLog('TP2 hit — selling'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp2').value=''; }
            else if(tp3 && price >= tp3){ safeLog('TP3 hit — selling'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp3').value=''; }
            else if(sl && price <= sl){ safeLog('SL hit — selling'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); }
          } else {
            if(tp1 && price <= tp1){ safeLog('TP1 hit — buying'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp1').value=''; }
            else if(tp2 && price <= tp2){ safeLog('TP2 hit — buying'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp2').value=''; }
            else if(tp3 && price <= tp3){ safeLog('TP3 hit — buying'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); el('tp3').value=''; }
            else if(sl && price >= sl){ safeLog('SL hit — buying (stop-loss)'); await swapExactTokens(tokenFrom, tokenTo, amount, slippage); }
          }
        }catch(e){ safeLog('bot error: ' + e); }
      }

      el('btnStart').addEventListener('click', async function(){
        if(!web3Provider || !signer){ alert('Connect wallet terlebih dahulu'); return; }
        const net = await web3Provider.getNetwork(); if(Number(net.chainId)!==BSC_CHAIN_ID){ alert('Switch ke BSC Mainnet di wallet Anda'); return; }
        // validate decimals before starting
        try{ await readDecimals(el('tokenFrom').value); await readDecimals(el('tokenTo').value); }catch(e){ alert('Token tidak valid di jaringan ini: ' + e); return; }
        el('status').textContent = 'Bot running'; safeLog('Bot started'); botInterval = setInterval(checkAndAct, 8000); checkAndAct(); el('btnStart').disabled = true; el('btnStop').disabled = false;
      });

      el('btnStop').addEventListener('click', function(){ if(botInterval){ clearInterval(botInterval); botInterval = null; el('status').textContent = 'Bot stopped'; safeLog('Bot stopped'); el('btnStop').disabled = true; el('btnStart').disabled = false; } else { alert('Bot tidak berjalan'); } });

    });
  </script>
</body>
</html>
