<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Auto-Trading XRP</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.emailjs.com/dist/email.min.js"></script>
  <style>
    body { font-family: sans-serif; background: #f7f7f7; margin: 0; padding: 2rem; }
    #chartContainer { width: 100%; max-width: 900px; margin: auto; }
    #log { white-space: pre-wrap; background: #eee; padding: 1rem; height: 200px; overflow-y: scroll; }
    button { padding: 10px 15px; margin: 5px; }
  </style>
</head>
<body>
  <h2>Harga XRP "simulasi.html" & Indikator (Real-time + Historis)</h2>
  <button onclick="connectWallet()">üîó Connect MetaMask</button>
  <button onclick="autoSwap('buy', qtyPerTrade)">üü¢ BUY XRP (Manual)</button>
  <button onclick="autoSwap('sell', qtyPerTrade)">üî¥ SELL XRP (Manual)</button>
  <div id="wallet"></div>

  <div id="chartContainer">
    <canvas id="priceChart"></canvas>
  </div>

  <h3>üìú Log:</h3>
  <div id="log"></div>

  <script>
    let provider, signer, router;
    let walletAddress = "";
    let currentChainId;
    let xrpPrices = [];
    let previousPrice = null;
    let chart;
    let currentPositionAmount = 0;
    const qtyPerTrade = 5;

    const PANCAKE_ROUTER_ADDRESS = "0x10ED43C718714eb63d5aA57B78B54704E256024E";
    const XRP_ADDRESS = "0x1D2F0dA169ceB9Fc7A0cFc94fC57BcC7A9F5217C";
    const USDT_ADDRESS = "0x55d398326f99059fF775485246999027B3197955";

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      const logBox = document.getElementById("log");
      logBox.textContent += `\n[${time}] ${msg}`;
      logBox.scrollTop = logBox.scrollHeight;
    }

    async function connectWallet() {
      if (!window.ethereum) return log("‚ùå MetaMask tidak terdeteksi");
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      walletAddress = await signer.getAddress();
      currentChainId = (await provider.getNetwork()).chainId;
      if (currentChainId !== 56) await switchToBSC();

      const balance = await provider.getBalance(walletAddress);
      document.getElementById("wallet").innerHTML = `üëõ Wallet: ${walletAddress}<br>üíµ Saldo: ${ethers.utils.formatEther(balance)} BNB`;

      router = new ethers.Contract(
        PANCAKE_ROUTER_ADDRESS,
        [
          "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) returns (uint[] memory)",
          "function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory)"
        ],
        signer
      );

      log(`‚úÖ Terhubung ke BNB Smart Chain: ${walletAddress} | Saldo: ${ethers.utils.formatEther(balance)} BNB`);
    }

    async function switchToBSC() {
      await window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [{
          chainId: '0x38',
          chainName: 'BNB Smart Chain',
          nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
          rpcUrls: ['https://bsc-dataseed.binance.org'],
          blockExplorerUrls: ['https://bscscan.com']
        }]
      });
      log("‚úÖ Berhasil switch ke jaringan BNB Smart Chain");
    }

    async function fetchHistoricalPrices() {
      const res = await axios.get("https://api.coingecko.com/api/v3/coins/ripple/market_chart", {
        params: {
          vs_currency: "usd",
          days: 14,
          interval: "hourly"
        }
      });
      const prices = res.data.prices.map(p => ({ x: new Date(p[0]).toLocaleString(), y: p[1] }));
      xrpPrices = prices.slice(-50);
      previousPrice = xrpPrices[xrpPrices.length - 2]?.y ?? null;
    }

    function updateChart(price, lowerBB = null, upperBB = null) {
      const time = new Date().toLocaleTimeString();
      xrpPrices.push({ x: time, y: price });
      if (xrpPrices.length > 50) xrpPrices.shift();

      chart.data.labels = xrpPrices.map(p => p.x);
      chart.data.datasets[0].data = xrpPrices.map(p => p.y);

      if (lowerBB !== null && upperBB !== null) {
        chart.data.datasets[1].data = Array(xrpPrices.length).fill(lowerBB);
        chart.data.datasets[2].data = Array(xrpPrices.length).fill(upperBB);
      }

      chart.update();
    }

    function initChart() {
      const ctx = document.getElementById("priceChart").getContext("2d");
      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Harga XRP (USD)",
              data: [],
              borderWidth: 2,
              borderColor: "blue",
              fill: false,
            },
            {
              label: "Lower BB",
              data: [],
              borderWidth: 1,
              borderColor: "green",
              borderDash: [5, 5],
              fill: false,
            },
            {
              label: "Upper BB",
              data: [],
              borderWidth: 1,
              borderColor: "red",
              borderDash: [5, 5],
              fill: false,
            }
          ]
        },
        options: { responsive: true, scales: { y: { beginAtZero: false } } }
      });
    }

    async function autoSwap(action, amountUSD) {
      try {
        const amountIn = ethers.utils.parseUnits(amountUSD.toString(), 18);
        const userAddress = await signer.getAddress();

        const tokenIn = action === "buy" ? USDT_ADDRESS : XRP_ADDRESS;
        const tokenOut = action === "buy" ? XRP_ADDRESS : USDT_ADDRESS;

        const tokenContract = new ethers.Contract(tokenIn, ["function approve(address spender, uint256 amount) public returns (bool)"], signer);
        const txApprove = await tokenContract.approve(PANCAKE_ROUTER_ADDRESS, amountIn);
        await txApprove.wait();

        const path = [tokenIn, tokenOut];
        const deadline = Math.floor(Date.now() / 1000) + 60 * 5;

        const tx = await router.swapExactTokensForTokens(amountIn, 0, path, userAddress, deadline);
        await tx.wait();

        log(`‚úÖ Swap ${action.toUpperCase()} XRP berhasil`);
        sendEmail(`AUTO-TRADE ${action.toUpperCase()}`, `Swap otomatis ${action.toUpperCase()} XRP sebesar $${amountUSD}`);
      } catch (err) {
        log("‚ùå Gagal auto-swap: " + err.message);
      }
    }

    function sendEmail(subject, message) {
      emailjs.send("YOUR_SERVICE", "YOUR_TEMPLATE", {
        subject: subject,
        message: message
      });
    }

    async function fetchAndEvaluate() {
      const res = await axios.get("https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd");
      const price = res.data.ripple.usd;

      const peak = Math.max(...xrpPrices.map(p => p.y), price);
      const low = Math.min(...xrpPrices.map(p => p.y), price);
      const range = peak - low;
      const lowerBB = low + range * 0.1;
      const upperBB = peak - range * 0.1;

      updateChart(price, lowerBB, upperBB);

      if (previousPrice !== null) {
        if (previousPrice < lowerBB && price >= lowerBB) {
          await autoSwap("buy", qtyPerTrade);
          sendEmail("BUY Signal", `Rebound dari Lower BB di $${price.toFixed(4)}`);
          currentPositionAmount += qtyPerTrade / price;
        } else if (previousPrice > upperBB && price <= upperBB && currentPositionAmount > 0) {
          await autoSwap("sell", price * currentPositionAmount);
          sendEmail("SELL Signal", `Rebound dari Upper BB di $${price.toFixed(4)}`);
          currentPositionAmount = 0;
        } else {
          log(`‚è≥ HOLD | Harga: $${price.toFixed(4)} | Lower BB: $${lowerBB.toFixed(4)} | Upper BB: $${upperBB.toFixed(4)}`);
        }
      }

      previousPrice = price;
    }

    emailjs.init("YOUR_USER_ID");

    async function startBot() {
      await fetchHistoricalPrices();
      initChart();
      setInterval(fetchAndEvaluate, 15000);
    }

    startBot();
  </script>
</body>
</html>
