<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRP↔USDT Auto Trader (BSC) — Stable</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:#071024;color:#e6eef8;margin:0;padding:20px}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:linear-gradient(180deg,#081428,#06101a);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);}    
    h1{margin:0 0 10px;font-size:20px}
    label{display:block;margin-top:10px;color:#9fb0d0;font-size:13px}
    input,select,button{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit}
    .row{display:flex;gap:12px}
    .col{flex:1}
    .small{font-size:13px;color:#99b3d6}
    pre{white-space:pre-wrap;word-break:break-word;background:transparent;padding:8px}
    .muted{color:#7f9ec8}
    @media(max-width:880px){.row{flex-direction:column}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>XRP ↔ USDT Auto Trader (BSC) — Stable</h1>
      <div class="small muted">Versi stabil: memitigasi error provider.emit dengan wrapper/proxy dan fallback ke window.ethereum. Masih DEMO — uji di testnet dulu.</div>

      <label>Connect Wallet</label>
      <div class="row">
        <input id="address" placeholder="Belum terhubung" readonly />
        <div style="width:140px"><button id="btnConnect">Connect</button></div>
      </div>

      <label>Network</label>
      <div class="row">
        <input id="network" placeholder="BSC Mainnet expected" readonly />
        <input id="balance" placeholder="Balance" readonly />
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <label>Token Addresses (BEP20)</label>
      <div class="row">
        <div class="col"><input id="tokenA" placeholder="Token A (XRP-BEP20)" value="" /></div>
        <div style="width:220px"><input id="decA" placeholder="decimals A (auto)" readonly /></div>
      </div>
      <div class="row">
        <div class="col"><input id="tokenB" placeholder="Token B (USDT-BEP20)" value="0x55d398326f99059fF775485246999027B3197955" /></div>
        <div style="width:220px"><input id="decB" placeholder="decimals B (auto)" readonly /></div>
      </div>

      <label>Direction</label>
      <select id="direction">
        <option value="AtoB">XRP → USDT (sell XRP)</option>
        <option value="BtoA">USDT → XRP (buy XRP)</option>
      </select>

      <label>Amount (amount of source token to trade)</label>
      <input id="amount" placeholder="contoh: 100 (XRP) atau 10 (USDT)" />

      <label>Targets (harga dalam unit token B per 1 token A — mis. USDT per 1 XRP)</label>
      <div class="row">
        <div class="col"><input id="tp1" placeholder="TP1" /></div>
        <div class="col"><input id="tp2" placeholder="TP2 (optional)" /></div>
        <div class="col"><input id="tp3" placeholder="TP3 (optional)" /></div>
      </div>
      <label>Stop Loss (SL)</label>
      <input id="sl" placeholder="SL" />

      <label>Slippage tolerance (%)</label>
      <input id="slippage" placeholder="0.5" value="0.5" />

      <div class="row" style="margin-top:12px;">
        <button id="btnStart" disabled>Start Bot</button>
        <button id="btnStop" disabled>Stop Bot</button>
      </div>

      <div style="margin-top:12px">
        <div class="small muted">Status</div>
        <div id="status">idle</div>
        <label style="margin-top:8px">Logs</label>
        <pre id="log">— ready —</pre>
      </div>

      <div style="margin-top:14px;color:#ffd1a9;font-size:13px">
        <strong>PERINGATAN:</strong> Kode ini akan menandatangani transaksi nyata jika kamu menghubungkan wallet dan menekan Start. Jalankan hanya jika memahami risiko — gas fees, slippage, MEV, rugpull token. UJI DI TESTNET TERLEBIH DAHULU.
      </div>
    </div>
  </div>

  <!-- Deps -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3modal@1.9.12/dist/index.js"></script>

  <script>
    // global error handler
    window.addEventListener('error', function (ev) {
      try { const msg = (ev && ev.error && ev.error.stack) ? ev.error.stack : ev.message || String(ev); document.getElementById('log').textContent = new Date().toLocaleTimeString() + ' — ERROR: ' + msg + '\n' + document.getElementById('log').textContent; } catch(e) { console.error('log error', e); }
    });

    window.addEventListener('load', function(){
      function el(id){ return document.getElementById(id); }
      function safeLog(msg){ try{ el('log').textContent = new Date().toLocaleTimeString() + ' — ' + String(msg) + '\n' + el('log').textContent; }catch(e){ console.log('log write failed', e); } console.log(msg); }

      if(typeof ethers === 'undefined'){ alert('ethers.js gagal dimuat. Periksa CDN / koneksi.'); safeLog('ethers.js not loaded'); return; }

      const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
      const WBNB = '0xBB4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';

      let provider = null; // low-level provider returned by Web3Modal
      let safeProvider = null; // proxied provider that guarantees .on/.emit etc
      let web3Provider = null; // ethers provider
      let signer = null;
      let account = null;
      let botInterval = null;
      let pollInterval = null;

      // Web3Modal config
      const providerOptions = {
        walletconnect: {
          package: window.WalletConnectProvider && window.WalletConnectProvider.default ? window.WalletConnectProvider.default : window.WalletConnectProvider,
          options: { rpc: { 56: 'https://bsc-dataseed.binance.org/' } }
        }
      };
      const Web3ModalCtor = window.Web3Modal && (window.Web3Modal.default || window.Web3Modal);
      const web3Modal = Web3ModalCtor ? new Web3ModalCtor({ cacheProvider:false, providerOptions }) : null;

      // Create a Proxy wrapper that provides safe .on/.off/.emit methods if missing.
      function makeSafeProvider(p){
        if(!p) return p;
        try{
          const handler = {
            get(target, prop, receiver){
              // for common event methods, return bound original or noop
              if(['on','off','addListener','removeListener','removeAllListeners','emit'].includes(prop)){
                if(typeof target[prop] === 'function'){
                  return target[prop].bind(target);
                }
                return function(){ /* noop to avoid crashes in libs expecting events */ };
              }
              try{ return Reflect.get(target, prop, receiver); }catch(e){ return undefined; }
            }
          };
          return new Proxy(p, handler);
        }catch(e){
          safeLog('Proxy creation failed — returning original provider: ' + e);
          return p;
        }
      }

      async function connect(){
        if(!web3Modal){ alert('Web3Modal tidak tersedia'); return; }
        try{
          // Try web3modal first
          provider = await web3Modal.connect().catch(function(err){ safeLog('web3Modal.connect failed: ' + err); return null; });

          // fallback to window.ethereum if available
          if(!provider && window.ethereum){ provider = window.ethereum; safeLog('Using window.ethereum fallback'); }

          if(!provider){ alert('Gagal menginisialisasi provider. Pastikan wallet Anda mendukung WalletConnect atau ada window.ethereum.'); return; }

          // wrap provider to avoid undefined .emit errors in downstream libs
          safeProvider = makeSafeProvider(provider);
          web3Provider = new ethers.providers.Web3Provider(safeProvider, 'any');
          signer = web3Provider.getSigner();
          try{ account = await signer.getAddress(); }catch(e){ account = null; }
          if(account) el('address').value = account;

          try{ const net = await web3Provider.getNetwork(); el('network').value = net.name + ' (' + net.chainId + ')'; }catch(e){ el('network').value = '—'; }
          try{ const bal = account ? await web3Provider.getBalance(account) : null; el('balance').value = bal ? ethers.utils.formatEther(bal) + ' BNB' : '—'; }catch(e){ el('balance').value = '—'; }

          safeLog('Connected ' + (account||'?'));

          // Start polling for account/network changes (avoid relying on provider.emit/on)
          if(pollInterval) clearInterval(pollInterval);
          pollInterval = setInterval(async function(){
            try{
              if(!web3Provider) return;
              const currentNet = await web3Provider.getNetwork();
              el('network').value = currentNet.name + ' (' + currentNet.chainId + ')';
              if(signer){
                try{ const currentAccount = await signer.getAddress(); if(currentAccount && currentAccount !== account){ account = currentAccount; el('address').value = account; safeLog('account changed: ' + account); } }catch(e){}
                try{ const bal = account ? await web3Provider.getBalance(account) : null; el('balance').value = bal ? ethers.utils.formatEther(bal) + ' BNB' : '—'; }catch(e){}
              }
            }catch(e){ /* silent */ }
          }, 3500);

          el('btnStart').disabled = false;
          el('btnStop').disabled = false;
        }catch(e){ safeLog('connect error: ' + e); }
      }

      async function disconnect(){
        try{ if(provider && typeof provider.disconnect === 'function') await provider.disconnect(); }catch(e){ /* ignore */ }
        try{ if(web3Modal && typeof web3Modal.clearCachedProvider === 'function') web3Modal.clearCachedProvider(); }catch(e){}
        if(pollInterval){ clearInterval(pollInterval); pollInterval = null; }
        provider = null; safeProvider = null; web3Provider = null; signer = null; account = null;
        el('address').value = '';
        el('network').value = '';
        el('balance').value = '';
        el('btnStart').disabled = true;
        el('btnStop').disabled = true;
        safeLog('Disconnected');
      }

      el('btnConnect').addEventListener('click', async function(){ if(!provider) await connect(); else await disconnect(); });

      // helpers using ethers provider
      async function getDecimals(token){ if(!web3Provider) throw new Error('provider not ready'); const erc20 = new ethers.Contract(token, ['function decimals() view returns (uint8)'], web3Provider); try{ return await erc20.decimals(); }catch(e){ safeLog('decimals read error: '+e); return null; } }

      async function getPrice(tokenIn, tokenOut, amountInHuman){ if(!web3Provider) throw new Error('provider not ready'); try{
        const router = new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider);
        const decIn = await getDecimals(tokenIn); const decOut = await getDecimals(tokenOut);
        if(decIn==null||decOut==null) throw new Error('failed decimals');
        const amountIn = ethers.utils.parseUnits(String(amountInHuman), decIn);
        try{ const amounts = await router.getAmountsOut(amountIn, [tokenIn, tokenOut]); return Number(ethers.utils.formatUnits(amounts[amounts.length-1], decOut)); }
        catch(e){ const amounts = await router.getAmountsOut(amountIn, [tokenIn, WBNB, tokenOut]); return Number(ethers.utils.formatUnits(amounts[amounts.length-1], decOut)); }
      }catch(e){ safeLog('getPrice error: '+e); throw e; } }

      async function approveIfNeeded(token, spender, amountHuman){ if(!signer) throw new Error('signer not ready'); const dec = await getDecimals(token); if(dec==null) throw new Error('decimals unknown'); const erc = new ethers.Contract(token, ['function allowance(address owner, address spender) view returns (uint256)','function approve(address spender, uint256 amount) returns (bool)'], signer); try{ const allowance = await erc.allowance(account, spender); const amount = ethers.utils.parseUnits(String(amountHuman), dec); if(allowance.gte(amount)){ safeLog('Allowance sufficient'); return true; } const tx = await erc.approve(spender, ethers.constants.MaxUint256); safeLog('Approve tx sent: ' + tx.hash); await tx.wait(); safeLog('Approve confirmed'); return true; }catch(e){ safeLog('approve error: '+e); throw e; } }

      async function swapExactTokens(tokenIn, tokenOut, amountInHuman, slippagePercent){ if(!signer) throw new Error('signer not ready'); const router = new ethers.Contract(PANCAKE_ROUTER, ['function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external'], signer); const decIn = await getDecimals(tokenIn); const decOut = await getDecimals(tokenOut); const amountIn = ethers.utils.parseUnits(String(amountInHuman), decIn);
        let amountsOut;
        try{ amountsOut = await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, [tokenIn, tokenOut]); }
        catch(e){ amountsOut = await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, [tokenIn, WBNB, tokenOut]); }
        const estOut = amountsOut[amountsOut.length-1];
        const amountOutMin = estOut.mul(10000 - Math.floor(slippagePercent*100)).div(10000);
        let path = [tokenIn, tokenOut];
        try{ await (new ethers.Contract(PANCAKE_ROUTER, ['function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory amounts)'], web3Provider)).getAmountsOut(amountIn, path); }catch(e){ path = [tokenIn, WBNB, tokenOut]; }
        const to = account; const deadline = Math.floor(Date.now()/1000) + 60*10;
        await approveIfNeeded(tokenIn, PANCAKE_ROUTER, amountInHuman);
        const tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, amountOutMin, path, to, deadline, { gasLimit: 800000 }); safeLog('Swap tx sent: ' + tx.hash); const receipt = await tx.wait(); safeLog('Swap confirmed: ' + receipt.transactionHash); return receipt; }

      // Bot logic
      async function checkAndAct(){ try{
        const tokenA = el('tokenA').value.trim(); const tokenB = el('tokenB').value.trim(); if(!ethers.utils.isAddress(tokenA) || !ethers.utils.isAddress(tokenB)){ safeLog('Masukkan alamat token valid untuk A dan B'); return; }
        const direction = el('direction').value; const amount = Number(el('amount').value); if(!amount || amount<=0){ safeLog('Amount invalid'); return; }
        const price = await getPrice(tokenA, tokenB, 1); safeLog('Market price (1 A → B): ' + price);
        const tp1 = Number(el('tp1').value) || null; const tp2 = Number(el('tp2').value) || null; const tp3 = Number(el('tp3').value) || null; const sl = Number(el('sl').value) || null; const slippage = Number(el('slippage').value) || 0.5;
        if(direction === 'AtoB'){
          if(tp1 && price >= tp1){ safeLog('TP1 reached — executing sell A->B'); await swapExactTokens(tokenA, tokenB, amount, slippage); el('tp1').value=''; }
          else if(tp2 && price >= tp2){ safeLog('TP2 reached — executing sell A->B'); await swapExactTokens(tokenA, tokenB, amount, slippage); el('tp2').value=''; }
          else if(tp3 && price >= tp3){ safeLog('TP3 reached — executing sell A->B'); await swapExactTokens(tokenA, tokenB, amount, slippage); el('tp3').value=''; }
          else if(sl && price <= sl){ safeLog('SL reached — executing sell A->B'); await swapExactTokens(tokenA, tokenB, amount, slippage); }
        } else {
          if(tp1 && price <= tp1){ safeLog('TP1 reached — executing buy B->A'); await swapExactTokens(tokenB, tokenA, amount, slippage); el('tp1').value=''; }
          else if(tp2 && price <= tp2){ safeLog('TP2 reached — executing buy B->A'); await swapExactTokens(tokenB, tokenA, amount, slippage); el('tp2').value=''; }
          else if(tp3 && price <= tp3){ safeLog('TP3 reached — executing buy B->A'); await swapExactTokens(tokenB, tokenA, amount, slippage); el('tp3').value=''; }
          else if(sl && price >= sl){ safeLog('SL reached — executing buy B->A (stop-loss)'); await swapExactTokens(tokenB, tokenA, amount, slippage); }
        }
      }catch(e){ safeLog('bot error: ' + e); } }

      el('btnStart').addEventListener('click', async function(){
        if(!account){ alert('Connect wallet terlebih dahulu'); return; }
        if(botInterval){ alert('Bot sudah berjalan'); return; }
        const tokenA = el('tokenA').value.trim(); const tokenB = el('tokenB').value.trim(); if(!ethers.utils.isAddress(tokenA) || !ethers.utils.isAddress(tokenB)){ alert('Masukkan alamat token A dan B yang valid (BEP20)'); return; }
        try{ const a = await getDecimals(tokenA); const b = await getDecimals(tokenB); el('decA').value = a; el('decB').value = b; }catch(e){ safeLog('decimals failed: ' + e); }
        el('status').textContent = 'Bot running — monitoring...'; safeLog('Bot started'); botInterval = setInterval(checkAndAct, 8000); checkAndAct(); el('btnStop').disabled = false; el('btnStart').disabled = true;
      });

      el('btnStop').addEventListener('click', function(){ if(botInterval){ clearInterval(botInterval); botInterval = null; el('status').textContent = 'Bot stopped'; safeLog('Bot stopped'); el('btnStop').disabled = true; el('btnStart').disabled = false; } else { alert('Bot tidak berjalan'); } });

    }); // end load
  </script>
</body>
</html>
